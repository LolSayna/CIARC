{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CIARC - Riftonauts","text":""},{"location":"#overview","title":"Overview","text":"<p>This is the Riftonaut's CIARC repository. It implements software for MELVIN and the Operator Console for the ESA Computer In A Room Challenge 3.</p> <p>The project implements two packages: <code>melvonaut</code> and <code>rift-console</code>.</p> <p>The Operator Console, referred to as Rift-Console, implements a web application based on Quart, which provides an interface to visualize and control MELVIN in the satellite simulation. Moreover, it implements background tasks to analyse data from MELVIN and complete given objectives.</p> <p>The driver software for MELVIN, referred to as Melvonaut, implements an async Python service, which continuously operates MELVIN towards the completion of its tasks. Moreover, it provides endpoints to retrieve the collected data to the Rift-Console in the limited communication windows.</p>"},{"location":"#requirements","title":"Requirements","text":"<p>Melvonaut requires Python 3.12 and expects a live connection to the CIARC API.</p> <p>Rift-Console requires Docker and Docker Compose. It is recommended to also provide a public domain name to run the application via TLS. A local development version of Rift-Console also exists without docker.</p>"},{"location":"#installation","title":"Installation","text":""},{"location":"#melvonaut","title":"Melvonaut","text":"<p>For deployment of Melvonaut on Melvin, Python 3.12 is required. In order to provide an isolated installation that persists across reboots, we compile Python 3.12 in user space.</p> SSH into Melvin and execute the following commands <pre><code>cd /home\n\napt update\napt install git nano\n\n# Install Python 3.12 build dependencies\napt -y install build-essential zlib1g-dev libncurses5-dev libgdbm-dev libnss3-dev libssl-dev libreadline-dev libffi-dev libsqlite3-dev wget libbz2-dev\n\n# Get and build Python 3.12.9, newest 3.12 at the time of writing\nwget https://www.python.org/ftp/python/3.12.9/Python-3.12.9.tgz\ntar xzf Python-3.12.9.tgz\nrm Python-3.12.9.tgz\ncd Python-3.12.9\n./configure --enable-optimizations\n\n# This takes some time\nmake -j 16\n\n# Verify that it worked\n./python --version\n\n# Install Melvonaut\ncd /home\ngit clone https://github.com/LolSayna/CIARC\ncd CIARC\n../Python-3.12.9/python -m venv venv\nsource venv/bin/activate\npip install poetry\npoetry install --with melvonaut\n\n# Optional, reset the container to remove the build dependencies\nkill 1\n\n# Run Melvonaut with\n./start-melvonaut.sh\n# To let it run in the background use\n./start-melvonaut.sh &amp; disown\n\n# To follow the logs\ncd /home/CIARC/logs/melvonaut\n# Replace yyyy-mm-dd-hh with the current date or look for the newest file\ntail -f log_melvonaut_yyyy-mm-dd-hh.log\n\n# To stop Melvonaut restart the container\nkill 1\n\n# To update\ngit pull\n\n# To be able to update after restarting the container, git must be reinstalled\napt update\napt install git\n</code></pre> <p>Melvonaut supports sending error messages via Discord while network simulation is deactivated or during communication windows. To use this, a Discord webhook must be set via the environment variable <code>DISCORD_WEBHOOK_TOKEN</code>. This can be done by copying the <code>.env.example</code> file to <code>.env</code> and inserting the token retrieved from Discord. Also <code>DISCORD_ALERTS_ENABLED</code> must be set to True in the <code>.env</code> file.</p>"},{"location":"#rift-console","title":"Rift-Console","text":"<p>Rift-Console is intended to be deployed via docker-compose on a node running a wire-guard connection to MELVIN and the CIARC API.</p> <p>Ensure that docker and docker-compose are installed. Rift-console is intended to be deployed on a public domain. If available edit <code>nginx.conf</code> to add the public domain under <code>map \"\" $domain</code> and the IP of the host under <code>map \"\" $host_ip</code>.</p> <p>To run the application via TLS, lets encrypt may be used. Edit the file <code>letsencrypt-config.sh</code> and add your domain and IP address. It is recommended to test with the staging environment active first. Then run <code>./init-letsencrypt.sh</code> to generate the initial certificates. The host must be publicly reachable on port 80 and 443.</p> <p>Rift-console is protected via HTTP Basic Authentication. Valid username and password pairs are read from <code>.http-pass</code>. Install <code>htpasswd</code> via the respective package, e.g., <code>apt install apache2-utils</code>. Run <code>htpasswd .http-pass username</code> to create a new user. You will be prompted for a password.</p> <p>To deploy the Rift-Console using docker-compose, run <code>make docker-compose-up</code>. This builds the image and starts the containers. Follow the logs with <code>docker-compose logs -f</code>. To stop the containers run <code>docker-compose down</code>.</p> <p>If no public domain is available, Rift-Console can also be run locally. Run <code>docker-compose up --build -d rift-console</code> to start the container. Rift-Console is available at <code>http://localhost:3000/</code></p> <p>The docker-compose setup also includes mkdocs. The docs can be found at <code>https://&lt;your-domain&gt;/docs</code>.</p> <p>Rift-Console uses an API exposed by Melvonaut to retrieve data and send control commands. For this Rift-Console expects the Melvonaut API to be reachable at http://localhost:8080/. When not running Melvonaut locally, port forwarding should be used. A script for this is provided in the <code>ssh-scripts</code> directory as <code>ssh-forward-melvonaut-api.sh</code>. The script requires a file <code>.ssh-pw</code> containing the password for the ssh connection and sshpass to be installed or can be modifyed to use an ssh-key.</p>"},{"location":"#usage","title":"Usage","text":""},{"location":"#melvonaut_1","title":"Melvonaut","text":"<p>Run <code>poetry run melvonaut</code> to start the service. Run <code>poetry run  melvonaut --help</code> for more information.</p> <p>For production deployment use the <code>start-melvonaut.sh</code> script. This includes automatic restarts on crashes.</p> <p>To remotely control Melvonaut, additional scripts are provided in <code>ssh-scripts</code>.</p>"},{"location":"#rift-console_1","title":"Rift-Console","text":"<p>Run <code>poetry run rift-console run-server</code> to start the service locally. Rift-Console can then be controlled from the web interface at http://localhost:3000.</p>"},{"location":"#development","title":"Development","text":"<p>The implementation uses Python 3.12 and Poetry.</p> <p>The easiest way to set up Poetry is to install pipx and then to run <pre><code>pipx install poetry\n</code></pre> It is assumed that Python 3.12 is available on the system.</p>"},{"location":"#installation_1","title":"Installation","text":"<p>To install Melvonaut and Rift-Console with all dependencies, run the following commands <pre><code># Prepare the virtual environment\npoetry config virtualenvs.in-project true\npoetry env use python3.12\npoetry install --all-groups\n\n# Then activate the virtual environment via\nsource $(poetry env info --path)/bin/activate\n# or\nsource .venv/bin/activate\n</code></pre></p> <p>This installs the Melvonaut, Rift-Console and development dependencies and allows running Melvonaut and Rift-Console locally via <code>melvonaut</code> and <code>rift-console</code>, respectively.</p>"},{"location":"#architecture","title":"Architecture","text":"<p>The diagram above shows the architecture of Melvonaut and Rift-Console in the context of CIARC. On the left side is the Operator Console, which runs on a VM with the Rift-Console and an NGINX Reverse Proxy are deployed as containers. NGINX exposes access to web interface of the Rift-Console via a public domain, using HTTP authentication to secure the access.</p> <p>The Rift-Console consists of a web interface, which enables controlling Melvonaut as well as the simulation. To control the simulation, the Rift-Console is able to send requests to the simulation control API. For controlling Melvonaut, the Rift-Console connects to an API provided by Melvonaut. The Melvonaut API is only reachable during communication windows via an SSH tunnel to Melvin. Besides performing control operations, the Melvonaut API also allows for downloading files such as logs and images. Moreover, the Rift-Console also implements an image stitching system to assemble pictures for objectives and the world map.</p> <p>The Operator Console VM also runs a WireGuard client to connect to the isolation layer, .i.e., the internal network of Melvin and the data reference system. On Melvin runs Melvonaut as a Python program. Melvonaut is managed by the state planer, which determines when to switch tasks. The Melvin API caller connects to the data reference system to collect telemetry data, request images and trigger state changes and other control operations. The current state is refreshed multiple times per second such that the state planer can wait for certain conditions to activate components and trigger state changes based on the current task. For example, when the state planer detects that the current battery level is below a certain threshold, it will trigger a switch to charge mode. The conditions and activations the state planer performs are based on the settings, which can be updated through the Melvonaut API from the Rift-Console.</p>"},{"location":"#code-structure","title":"Code Structure","text":"Folders &amp; Files <pre><code>\u251c\u2500\u2500 data                                              # NGINX and Certbot data\n\u251c\u2500\u2500 docker-compose.yml\n\u251c\u2500\u2500 Dockerfile                                        # Rift-Console Dockerfile\n\u251c\u2500\u2500 Dockerfile.mkdocs                                 # Mkdocs Dockerfile\n\u251c\u2500\u2500 docs                                              # Project docs\n\u251c\u2500\u2500 init-letsencrypt.sh\n\u251c\u2500\u2500 letsencrypt-config.sh\n\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 logs\n\u2502     \u251c\u2500\u2500 melvonaut\n\u2502     \u2502     \u251c\u2500\u2500 event_melvonaut.csv                   # Announcements captured form stream\n\u2502     \u2502     \u251c\u2500\u2500 images                                # Saved images\n\u2502     \u2502     \u2514\u2500\u2500 log_melvonaut_XXXX.log                # Python logging\n\u2502     \u2502     \u2514\u2500\u2500 telemetry_melvonaut.csv               # Telemetry\n\u2502     \u2502     \u2514\u2500\u2500 persistent_settings.json              # Settings that override defaults\n\u2502     \u2514\u2500\u2500 rift_console\n\u2502         \u251c\u2500\u2500 from_melvonaut                          # Logs/Events/Telemetry downloaded from Melvonaut\n\u2502         \u2514\u2500\u2500 images                                  # Downloaded/Stitched/Processed images\n\u251c\u2500\u2500 Makefile\n\u251c\u2500\u2500 media                                             # Static files for docs\n\u251c\u2500\u2500 mkdocs.yml\n\u251c\u2500\u2500 nginx.conf\n\u251c\u2500\u2500 poetry.lock\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 src\n\u2502     \u251c\u2500\u2500 melvonaut\n\u2502     \u2502     \u251c\u2500\u2500 __init__.py\n\u2502     \u2502     \u251c\u2500\u2500 __main__.py                           # Main control flow\n\u2502     \u2502     \u251c\u2500\u2500 api.py                                # Melvonaut API, consumed by Rift-Console\n\u2502     \u2502     \u251c\u2500\u2500 ebt_calc.py                           # Beacon calculator\n\u2502     \u2502     \u251c\u2500\u2500 mel_telemetry.py                      # Telemtry data class\n\u2502     \u2502     \u251c\u2500\u2500 settings.py                           # Melvonaut settings\n\u2502     \u2502     \u251c\u2500\u2500 state_planer.py                       # State management logic\n\u2502     \u2502     \u2514\u2500\u2500 utils.py                              # Helper functions\n\u2502     \u251c\u2500\u2500 rift_console\n\u2502     \u2502     \u251c\u2500\u2500 __init__.py\n\u2502     \u2502     \u251c\u2500\u2500 __main__.py                           # Quart routes + logic\n\u2502     \u2502     \u251c\u2500\u2500 rift_console.py                       # Dataclass\n\u2502     \u2502     \u251c\u2500\u2500 ciarc_api.py                          # Connection to CIARC API\n\u2502     \u2502     \u251c\u2500\u2500 melvin_api.py                         # Connection to Melvonaut API\n\u2502     \u2502     \u251c\u2500\u2500 image_processing.py                   # Image stitching\n\u2502     \u2502     \u251c\u2500\u2500 image_helper.py\n\u2502     \u2502     \u251c\u2500\u2500 static\n\u2502     \u2502     \u2502     \u251c\u2500\u2500 images\n\u2502     \u2502     \u2502     \u2514\u2500\u2500 satellite.svg\n\u2502     \u2502     \u2514\u2500\u2500 templates\n\u2502     \u2502         \u251c\u2500\u2500 main.html                         # Index page\n\u2502     \u2502         \u251c\u2500\u2500 live.html\n\u2502     \u2502         \u251c\u2500\u2500 downloads.html\n\u2502     \u2502         \u2514\u2500\u2500 stitched.html\n\u2502     \u2502         \u251c\u2500\u2500 ebt.html\n\u2502     \u2514\u2500\u2500 shared\n\u2502         \u251c\u2500\u2500 __init__.py\n\u2502         \u251c\u2500\u2500 constants.py                            # Shared constants\n\u2502         \u251c\u2500\u2500 models.py                               # Shared data classes\n\u251c\u2500\u2500 ssh-scripts\n\u2502     \u251c\u2500\u2500 ssh-forward-melvonaut-api.sh                # Port forward Melvonaut API to localhost\n\u2502     \u251c\u2500\u2500 ssh-git-pull-on-melvin.sh                   # Update CIARC on Melvin\n\u2502     \u251c\u2500\u2500 ssh-restart-melvin-container.sh             # Kill the Melvin container\n\u2502     \u251c\u2500\u2500 ssh-restart-melvonaut.sh                    # Stop Melvonaut and let wrapper restart it\n\u2502     \u251c\u2500\u2500 ssh-start-melvonaut.sh                      # Run wrapper start script\n\u2502     \u2514\u2500\u2500 ssh-stop-melvonaut.sh                       # Stop Melvonaut and wrapper script\n\u251c\u2500\u2500 start-melvonaut.sh                                # Wrapper script for restarting Melvonaut\n\u2514\u2500\u2500 tests\n    \u251c\u2500\u2500 test_melvonaut\n    \u2502     \u251c\u2500\u2500 __init__.py\n    \u2502     \u251c\u2500\u2500 conftest.py\n    \u2502     \u251c\u2500\u2500 test_api.py\n    \u2502     \u251c\u2500\u2500 test_main.py\n    \u2502     \u251c\u2500\u2500 test_models.py\n    \u2502     \u251c\u2500\u2500 test_settings.py\n    \u2502     \u2514\u2500\u2500 test_state_planer.py\n    \u2514\u2500\u2500 test_rift_console\n        \u251c\u2500\u2500 __init__.py\n        \u2514\u2500\u2500 test_main.py\n</code></pre>"},{"location":"#testing","title":"Testing","text":"<p>Melvonaut is tested using pytest. Tests can be run via <code>make test</code>. To run with coverage, run <code>make coverage</code>. The tests are also run via Github Actions.</p>"},{"location":"#type-checking-and-linting","title":"Type Checking and Linting","text":"<p>Use <code>make mypy</code> and <code>make lint</code> inside an active poetry enviroment.</p>"},{"location":"#license","title":"License","text":"<p>Distributed under the terms of the MIT license, Ciarc is free and open source software.</p>"},{"location":"license/","title":"License","text":"<p>MIT License</p> <p>Copyright \u00a9 2024 Riftonauts</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"melvonaut/","title":"Melvonaut Reference","text":"<p>Ciarc.</p>"},{"location":"melvonaut/#melvonaut.__main__","title":"<code>__main__</code>","text":"<p>Melvonaut :author: Jonathan Decker</p>"},{"location":"melvonaut/#melvonaut.__main__.current_telemetry","title":"<code>current_telemetry = None</code>  <code>module-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.__main__.cancel_tasks","title":"<code>cancel_tasks()</code>","text":"<p>Cancels all tasks and event loop.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/melvonaut/__main__.py</code> <pre><code>def cancel_tasks() -&gt; None:\n    \"\"\"Cancels all tasks and event loop.\n\n    Returns:\n        None\n    \"\"\"\n    for task in asyncio.all_tasks():\n        task.cancel()\n    loop = asyncio.get_running_loop()\n    loop.stop()\n</code></pre>"},{"location":"melvonaut/#melvonaut.__main__.get_announcements","title":"<code>get_announcements(last_id=None)</code>  <code>async</code>","text":"<p>Fetches announcements asynchronously with event-stream handling.</p> <p>This function continuously listens for new announcements from the API and processes them. If announcements are received, they are logged and stored.</p> <p>Parameters:</p> Name Type Description Default <code>last_id</code> <code>Optional[str]</code> <p>The ID of the last processed event to resume from, if applicable.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The ID of the last received announcement, or None if an error occurs.</p> Source code in <code>src/melvonaut/__main__.py</code> <pre><code>async def get_announcements(last_id: Optional[str] = None) -&gt; Optional[str]:\n    \"\"\"Fetches announcements asynchronously with event-stream handling.\n\n    This function continuously listens for new announcements from the API and processes them.\n    If announcements are received, they are logged and stored.\n\n    Args:\n        last_id (Optional[str]): The ID of the last processed event to resume from, if applicable.\n\n    Returns:\n        Optional[str]: The ID of the last received announcement, or None if an error occurs.\n    \"\"\"\n    content_line_regex = re.compile(r\"^\\[(\\d+)]\\s*(.*)$\")\n\n    headers = {\"Accept\": \"text/event-stream\", \"Cache-Control\": \"no-cache\"}\n    if last_id:\n        headers[\"Last-Event-ID\"] = last_id\n\n    timeout = aiohttp.ClientTimeout(\n        total=None, connect=None, sock_connect=None, sock_read=None\n    )\n\n    async with aiohttp.ClientSession(timeout=timeout) as session:\n        try:\n            async with session.get(\n                con.ANNOUNCEMENTS_ENDPOINT, headers=headers\n            ) as response:\n                if response.status not in [200, 301, 307]:\n                    logger.error(f\"Failed to get announcements: {response.status}\")\n                    await session.close()\n                    return None\n                else:\n                    # logger.error(response.content)\n                    # async for line in response.content:\n                    #    logger.error(line)\n                    async for line in response.content:\n                        line_decoded = line.decode(\"utf-8\")\n                        # logger.warning(f\"Received announcement {line}\")\n                        # logger.warning(f\"Location is: {state_planner.calc_current_location()}\")\n                        # logger.warning(f\"Received announcement with content:{line_decoded}\")\n                        line_filtered = line_decoded.replace(\"data:\", \"\").strip()\n\n                        match = content_line_regex.search(line_filtered)\n                        if match:\n                            line_id = int(match.group(1))\n                            line_content = str(match.group(2))\n                            timestamp = datetime.now(timezone.utc)\n                            current_x, current_y = state_planner.calc_current_location()\n\n                            current_event = Event(\n                                event=line_content,\n                                id=line_id,\n                                timestamp=timestamp,\n                                current_x=current_x,\n                                current_y=current_y,\n                            )\n\n                            logger.warning(\n                                f\"Received announcement: {current_event.model_dump()}\"\n                            )\n                            await current_event.to_csv()\n                            state_planner.recent_events.append(current_event)\n                            last_id = str(current_event.id)\n        except TimeoutError:\n            logger.error(\"Announcements subscription timed out\")\n        finally:\n            if response and not response.closed:\n                response.close()\n            if not session.closed:\n                await session.close()\n            return last_id\n</code></pre>"},{"location":"melvonaut/#melvonaut.__main__.get_observations","title":"<code>get_observations()</code>  <code>async</code>","text":"<p>Async get observations from the Melvin API and update the state planner</p> <p>This function establishes a session with the API and retrieves observation data. If the response is successful, it updates the telemetry state. If any errors occur, they are logged accordingly.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/melvonaut/__main__.py</code> <pre><code>async def get_observations() -&gt; None:\n    \"\"\"Async get observations from the Melvin API and update the state planner\n\n    This function establishes a session with the API and retrieves observation data.\n    If the response is successful, it updates the telemetry state.\n    If any errors occur, they are logged accordingly.\n\n    Returns:\n        None\n\n    \"\"\"\n    async with aiohttp.ClientSession() as session:\n        try:\n            async with session.get(con.OBSERVATION_ENDPOINT) as response:\n                if response.status == 200:\n                    json_response = await response.json()\n                    # logger.debug(\"Received observations\")\n                    # pprint(json_response, indent=4, sort_dicts=True)\n                    await state_planner.update_telemetry(MelTelemetry(**json_response))\n                else:\n                    logger.warning(f\"Failed to get observations: {response.status}\")\n        except aiohttp.client_exceptions.ConnectionTimeoutError:\n            logger.warning(\"Observations endpoint timeouted.\")\n        except asyncio.TimeoutError:\n            logger.warning(\"ASyncio TimeoutError occured.\")\n        except aiohttp.client_exceptions.ClientOSError:\n            logger.warning(\"Client_exceptions.ClienOSError occured.\")\n</code></pre>"},{"location":"melvonaut/#melvonaut.__main__.main","title":"<code>main()</code>","text":"<p>Melvonaut.</p> Source code in <code>src/melvonaut/__main__.py</code> <pre><code>@click.command()\n@click.version_option()\ndef main() -&gt; None:\n    \"\"\"Melvonaut.\"\"\"\n    utils.setup_logging()\n    logger.info(\"Starting Melvonaut...\")\n\n    start_event_loop()\n</code></pre>"},{"location":"melvonaut/#melvonaut.__main__.read_images","title":"<code>read_images()</code>  <code>async</code>","text":"<p>Reads image files asynchronously from a designated directory.</p> <p>This function iterates over stored images, extracts metadata from filenames, and yields <code>MelvinImage</code> objects.</p> <p>Yields:</p> Name Type Description <code>MelvinImage</code> <code>AsyncIterable[MelvinImage]</code> <p>An image object containing extracted metadata.</p> Source code in <code>src/melvonaut/__main__.py</code> <pre><code>async def read_images() -&gt; AsyncIterable[MelvinImage]:\n    \"\"\"Reads image files asynchronously from a designated directory.\n\n    This function iterates over stored images, extracts metadata from filenames, and\n    yields `MelvinImage` objects.\n\n    Yields:\n        MelvinImage: An image object containing extracted metadata.\n    \"\"\"\n    if not os.path.exists(con.IMAGE_PATH):\n        logger.warning(f\"{con.IMAGE_PATH} does not exist.\")\n        return\n\n    pattern = r\"image_melvonaut_angle_(\\w+)_x_(\\d+\\.\\d+)_y_(\\d+\\.\\d+)_(\\d{4}-\\d{2}-\\d{2}_\\d{2}-\\d{2}-\\d{2})\\.png\"\n\n    for filename in os.listdir(con.IMAGE_PATH):\n        if filename.endswith(\".png\"):\n            image_path = os.path.join(con.IMAGE_PATH, filename)\n            try:\n                async with async_open(image_path, \"rb\") as afp:\n                    data = await afp.read()\n                    image = Image.open(io.BytesIO(data))\n            except FileNotFoundError as e:\n                logger.warning(f\"{image_path} does not exist.\")\n                logger.debug(e)\n                continue\n            except IOError as e:\n                logger.warning(f\"Failed to read {image_path}\")\n                logger.debug(e)\n                continue\n            except ValueError as e:\n                logger.warning(f\"Failed to parse {image_path}\")\n                logger.debug(e)\n                continue\n            match = re.match(pattern, filename)\n            if match:\n                angle = CameraAngle(match.group(1))\n                cor_x = int(match.group(2))\n                cor_y = int(match.group(3))\n                time = datetime.strptime(match.group(4), \"%Y-%m-%d_%H-%M-%S\")\n                yield MelvinImage(\n                    image=image, angle=angle, cor_x=cor_x, cor_y=cor_y, time=time\n                )\n            else:\n                logger.warning(f\"Failed to parse {filename}.\")\n</code></pre>"},{"location":"melvonaut/#melvonaut.__main__.run_get_announcements","title":"<code>run_get_announcements()</code>  <code>async</code>","text":"<p>Continuously fetches announcements from the API.</p> <p>This function runs in an infinite loop, restarting the subscription when needed.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/melvonaut/__main__.py</code> <pre><code>async def run_get_announcements() -&gt; None:\n    \"\"\"Continuously fetches announcements from the API.\n\n    This function runs in an infinite loop, restarting the subscription when needed.\n\n    Returns:\n        None\n    \"\"\"\n    logger.warning(\"Started announcements subscription\")\n    while True:\n        await asyncio.gather(get_announcements())\n        logger.warning(\"Restarted announcements subscription\")\n</code></pre>"},{"location":"melvonaut/#melvonaut.__main__.run_get_observations","title":"<code>run_get_observations()</code>  <code>async</code>","text":"<p>Runs the observation fetching function in a loop.</p> <p>This function repeatedly fetches observations based on a specified refresh rate, adjusting for simulation speed.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/melvonaut/__main__.py</code> <pre><code>async def run_get_observations() -&gt; None:\n    \"\"\"Runs the observation fetching function in a loop.\n\n    This function repeatedly fetches observations based on a specified refresh rate,\n    adjusting for simulation speed.\n\n    Returns:\n        None\n    \"\"\"\n    await get_observations()\n    while True:\n        # logger.debug(\"Submitted observations request\")\n        observe_task = Timer(\n            timeout=settings.OBSERVATION_REFRESH_RATE\n            / state_planner.get_simulation_speed(),\n            callback=get_observations,\n        ).get_task()\n        await asyncio.gather(observe_task)\n</code></pre>"},{"location":"melvonaut/#melvonaut.__main__.run_read_images","title":"<code>run_read_images()</code>  <code>async</code>","text":"<p>Log all receives images.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/melvonaut/__main__.py</code> <pre><code>async def run_read_images() -&gt; None:\n    \"\"\"Log all receives images.\n\n    Returns:\n        None\n    \"\"\"\n    async for image in read_images():\n        logger.debug(f\"Received image: {image}\")\n</code></pre>"},{"location":"melvonaut/#melvonaut.__main__.start_event_loop","title":"<code>start_event_loop()</code>","text":"<p>Initializes and starts the asynchronous event loop.</p> <p>This function sets up signal handlers, registers tasks for fetching observations, announcements, and API interactions, and starts the event loop.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/melvonaut/__main__.py</code> <pre><code>def start_event_loop() -&gt; None:\n    \"\"\"Initializes and starts the asynchronous event loop.\n\n    This function sets up signal handlers, registers tasks for fetching observations,\n    announcements, and API interactions, and starts the event loop.\n\n    Returns:\n        None\n    \"\"\"\n    loop = uvloop.new_event_loop()\n\n    for sig in (signal.SIGINT, signal.SIGTERM):\n        loop.add_signal_handler(sig, cancel_tasks)\n\n    loop.set_default_executor(concurrent.futures.ThreadPoolExecutor(max_workers=1))\n\n    loop.create_task(run_get_observations())\n    loop.create_task(run_get_announcements())\n\n    loop.create_task(api.run_api())\n\n    # loop.create_task(run_read_images())\n\n    loop.run_forever()\n\n    for sig in (signal.SIGINT, signal.SIGTERM):\n        loop.remove_signal_handler(sig)\n\n    logger.info(\"Shutting down Melvonaut...\")\n</code></pre>"},{"location":"melvonaut/#melvonaut.api","title":"<code>api</code>","text":""},{"location":"melvonaut/#melvonaut.api.Handler","title":"<code>Handler = Callable[[web.Request], Awaitable[web.StreamResponse]]</code>  <code>module-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.api.catcher_middleware","title":"<code>catcher_middleware(request, handler)</code>  <code>async</code>","text":"<p>Middleware to catch and log unhandled exceptions in request handling.</p> <p>If an exception occurs while processing the request, this middleware logs the error and returns a 500 Internal Server Error response with the error message.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The incoming HTTP request.</p> required <code>handler</code> <code>Handler</code> <p>The next request handler in the middleware chain.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The HTTP response from the handler, or a 500 error response</p> <code>Any</code> <p>if an exception occurs.</p> Source code in <code>src/melvonaut/api.py</code> <pre><code>@web.middleware\nasync def catcher_middleware(request: web.Request, handler: Handler) -&gt; Any:\n    \"\"\"Middleware to catch and log unhandled exceptions in request handling.\n\n    If an exception occurs while processing the request, this middleware\n    logs the error and returns a 500 Internal Server Error response\n    with the error message.\n\n    Args:\n        request (web.Request): The incoming HTTP request.\n        handler (Handler): The next request handler in the middleware chain.\n\n    Returns:\n        Any: The HTTP response from the handler, or a 500 error response\n        if an exception occurs.\n    \"\"\"\n    try:\n        return await handler(request)\n    except Exception as e:\n        logger.exception(e)\n        return web.Response(status=500, text=str(e))\n</code></pre>"},{"location":"melvonaut/#melvonaut.api.compression_middleware","title":"<code>compression_middleware(request, handler)</code>  <code>async</code>","text":"<p>Middleware to handle response compression using gzip or deflate.</p> <p>This middleware checks the <code>Accept-Encoding</code> header of the request to determine if the client supports gzip or deflate compression. If supported, it applies the corresponding compression to the response.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The incoming HTTP request.</p> required <code>handler</code> <code>Handler</code> <p>The next request handler in the middleware chain.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The compressed HTTP response if the client supports it,</p> <code>Any</code> <p>otherwise the original response.</p> Source code in <code>src/melvonaut/api.py</code> <pre><code>@web.middleware\nasync def compression_middleware(request: web.Request, handler: Handler) -&gt; Any:\n    \"\"\"Middleware to handle response compression using gzip or deflate.\n\n    This middleware checks the `Accept-Encoding` header of the request\n    to determine if the client supports gzip or deflate compression.\n    If supported, it applies the corresponding compression to the response.\n\n    Args:\n        request (web.Request): The incoming HTTP request.\n        handler (Handler): The next request handler in the middleware chain.\n\n    Returns:\n        Any: The compressed HTTP response if the client supports it,\n        otherwise the original response.\n    \"\"\"\n    accept_encoding = request.headers.get(hdrs.ACCEPT_ENCODING, \"\").lower()\n\n    if ContentCoding.gzip.value in accept_encoding:\n        compressor = ContentCoding.gzip.value\n    elif ContentCoding.deflate.value in accept_encoding:\n        compressor = ContentCoding.deflate.value\n    else:\n        return await handler(request)\n\n    resp = await handler(request)\n    resp.headers[hdrs.CONTENT_ENCODING] = compressor\n    resp.enable_compression()\n    return resp\n</code></pre>"},{"location":"melvonaut/#melvonaut.api.get_all_settings","title":"<code>get_all_settings(request)</code>  <code>async</code>","text":"<p>Retrieve all settings configured in the system.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The incoming HTTP request.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>web.Response: JSON response containing all system settings.</p> Source code in <code>src/melvonaut/api.py</code> <pre><code>async def get_all_settings(request: web.Request) -&gt; web.Response:\n    \"\"\"Retrieve all settings configured in the system.\n\n    Args:\n        request (web.Request): The incoming HTTP request.\n\n    Returns:\n        web.Response: JSON response containing all system settings.\n    \"\"\"\n    logger.debug(\"Getting all settings\")\n    attrs = [key for key in dir(settings) if not key.startswith(\"_\") and key.isupper()]\n    all_settings: dict[str, Any] = {}\n    for attr in attrs:\n        value = settings.__getattribute__(attr)\n        if type(value) is float or type(value) is int:\n            all_settings[attr] = value\n        elif type(value) is datetime.datetime:\n            all_settings[attr] = value.isoformat()\n        else:\n            all_settings[attr] = str(value)\n    return web.json_response(all_settings, status=200)\n</code></pre>"},{"location":"melvonaut/#melvonaut.api.get_clear_all_images","title":"<code>get_clear_all_images(request)</code>  <code>async</code>","text":"<p>Clears all stored images.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The incoming HTTP request.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>web.Response: JSON response containing a list of cleared images.</p> Source code in <code>src/melvonaut/api.py</code> <pre><code>async def get_clear_all_images(request: web.Request) -&gt; web.Response:\n    \"\"\"Clears all stored images.\n\n    Args:\n        request (web.Request): The incoming HTTP request.\n\n    Returns:\n        web.Response: JSON response containing a list of cleared images.\n    \"\"\"\n    logger.debug(\"Clearing all images\")\n    folder = pathlib.Path(con.IMAGE_PATH_BASE)\n    images = [str(file) for file in folder.rglob(\"*.png\") if file.is_file()]\n    for image in images:\n        pathlib.Path(image).unlink()\n    return web.Response(status=200, text=\"OK\")\n</code></pre>"},{"location":"melvonaut/#melvonaut.api.get_clear_all_logs","title":"<code>get_clear_all_logs(request)</code>  <code>async</code>","text":"<p>Clears all log files in the system.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The incoming HTTP request.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>web.Response: JSON response containing a list of cleared log files.</p> Source code in <code>src/melvonaut/api.py</code> <pre><code>async def get_clear_all_logs(request: web.Request) -&gt; web.Response:\n    \"\"\"Clears all log files in the system.\n\n    Args:\n        request (web.Request): The incoming HTTP request.\n\n    Returns:\n        web.Response: JSON response containing a list of cleared log files.\n    \"\"\"\n    try:\n        logger.debug(\"Clearing all log files\")\n        log_files = []\n        folder = pathlib.Path(con.MEL_LOG_PATH)\n        for file in folder.iterdir():\n            if file.is_dir():\n                continue\n            if not file.name.endswith(\".log\"):\n                continue\n            log_files.append(file.name)\n            file.unlink()\n        utils.setup_file_logging()\n        return web.json_response({\"Cleared_files\": log_files}, status=200)\n    except Exception as e:\n        logger.exception(e)\n        return web.json_response({\"error\": str(e)}, status=500)\n</code></pre>"},{"location":"melvonaut/#melvonaut.api.get_clear_events","title":"<code>get_clear_events(request)</code>  <code>async</code>","text":"<p>Deletes the event log file from the system.</p> <p>If the event log file exists, it is deleted. If it does not exist, a 404 response is returned.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The incoming HTTP request.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>web.Response: A 200 response if the file is successfully deleted.</p> <code>Response</code> <p>web.Response: A 404 response if the file is not found.</p> Source code in <code>src/melvonaut/api.py</code> <pre><code>async def get_clear_events(request: web.Request) -&gt; web.Response:\n    \"\"\"Deletes the event log file from the system.\n\n    If the event log file exists, it is deleted. If it does not exist, a 404 response is returned.\n\n    Args:\n        request (web.Request): The incoming HTTP request.\n\n    Returns:\n        web.Response: A 200 response if the file is successfully deleted.\n        web.Response: A 404 response if the file is not found.\n    \"\"\"\n    logger.debug(\"Clearing events\")\n    events_file = pathlib.Path(con.EVENT_LOCATION_CSV)\n    if events_file.exists():\n        events_file.unlink()\n        return web.Response(status=200, text=\"OK\")\n    else:\n        return web.Response(status=404, text=\"File not found\")\n</code></pre>"},{"location":"melvonaut/#melvonaut.api.get_clear_telemetry","title":"<code>get_clear_telemetry(request)</code>  <code>async</code>","text":"<p>Clears the telemetry data file.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The incoming HTTP request.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>web.Response: A success response if the file is deleted, otherwise a 404 response.</p> Source code in <code>src/melvonaut/api.py</code> <pre><code>async def get_clear_telemetry(request: web.Request) -&gt; web.Response:\n    \"\"\"Clears the telemetry data file.\n\n    Args:\n        request (web.Request): The incoming HTTP request.\n\n    Returns:\n        web.Response: A success response if the file is deleted, otherwise a 404 response.\n    \"\"\"\n    logger.debug(\"Clearing telemetry\")\n    telemetry_file = pathlib.Path(con.TELEMETRY_LOCATION_CSV)\n    if telemetry_file.exists():\n        telemetry_file.unlink()\n        return web.Response(status=200, text=\"OK\")\n    else:\n        return web.Response(status=404, text=\"File not found\")\n</code></pre>"},{"location":"melvonaut/#melvonaut.api.get_cpu_usage","title":"<code>get_cpu_usage(request)</code>  <code>async</code>","text":"<p>Retrieve CPU usage statistics.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The incoming HTTP request.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>web.Response: JSON response containing CPU usage data including user, system, idle time, percent usage, core count, and frequency.</p> Source code in <code>src/melvonaut/api.py</code> <pre><code>async def get_cpu_usage(request: web.Request) -&gt; web.Response:\n    \"\"\"Retrieve CPU usage statistics.\n\n    Args:\n        request (web.Request): The incoming HTTP request.\n\n    Returns:\n        web.Response: JSON response containing CPU usage data including user, system, idle time, percent usage, core count, and frequency.\n    \"\"\"\n    logger.debug(\"Getting CPU usage\")\n    cpu_usage = psutil.cpu_times()\n    cpu_percent = psutil.cpu_percent()\n    cpu_count = psutil.cpu_count()\n    cpu_freq = psutil.cpu_freq()\n    cpu = {\n        \"user\": cpu_usage.user,\n        \"system\": cpu_usage.system,\n        \"idle\": cpu_usage.idle,\n        \"percent\": cpu_percent,\n        \"physical_cores\": cpu_count,\n        \"current_freq\": cpu_freq.current,\n        \"max_freq\": cpu_freq.max,\n        \"min_freq\": cpu_freq.min,\n    }\n    return web.json_response(cpu, status=200)\n</code></pre>"},{"location":"melvonaut/#melvonaut.api.get_disk_usage","title":"<code>get_disk_usage(request)</code>  <code>async</code>","text":"<p>Retrieve disk usage statistics for root and home directories.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The incoming HTTP request.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>web.Response: JSON response containing disk usage data.</p> Source code in <code>src/melvonaut/api.py</code> <pre><code>async def get_disk_usage(request: web.Request) -&gt; web.Response:\n    \"\"\"Retrieve disk usage statistics for root and home directories.\n\n    Args:\n        request (web.Request): The incoming HTTP request.\n\n    Returns:\n        web.Response: JSON response containing disk usage data.\n    \"\"\"\n    logger.debug(\"Getting disk usage\")\n    disk_root = psutil.disk_usage(\"/\")\n    disk_home = psutil.disk_usage(\"/home\")\n    return web.json_response(\n        {\"root\": disk_root._asdict(), \"home\": disk_home._asdict()}, status=200\n    )\n</code></pre>"},{"location":"melvonaut/#melvonaut.api.get_download_events","title":"<code>get_download_events(request)</code>  <code>async</code>","text":"<p>Handles the download of event logs.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The incoming HTTP request.</p> required <p>Returns:</p> Type Description <code>Response | FileResponse</code> <p>web.FileResponse: The requested event log file if it exists.</p> <code>Response | FileResponse</code> <p>web.Response: A 404 response if the file is not found.</p> Source code in <code>src/melvonaut/api.py</code> <pre><code>async def get_download_events(request: web.Request) -&gt; web.Response | web.FileResponse:\n    \"\"\"Handles the download of event logs.\n\n    Args:\n        request (web.Request): The incoming HTTP request.\n\n    Returns:\n        web.FileResponse: The requested event log file if it exists.\n        web.Response: A 404 response if the file is not found.\n    \"\"\"\n    logger.debug(\"Downloading events\")\n    events_file = pathlib.Path(con.EVENT_LOCATION_CSV)\n    if events_file.exists():\n        return web.FileResponse(events_file, status=200)\n    else:\n        return web.Response(status=404, text=\"File not found\")\n</code></pre>"},{"location":"melvonaut/#melvonaut.api.get_download_events_and_clear","title":"<code>get_download_events_and_clear(request)</code>  <code>async</code>","text":"<p>Downloads and clears the event log file.</p> <p>This function retrieves the event log file, sends its content as a response, and then deletes the file from the system.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The incoming HTTP request.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>web.Response: A response containing the event log content if found.</p> <code>Response</code> <p>web.Response: A 404 response if the file is not found.</p> Source code in <code>src/melvonaut/api.py</code> <pre><code>async def get_download_events_and_clear(request: web.Request) -&gt; web.Response:\n    \"\"\"Downloads and clears the event log file.\n\n    This function retrieves the event log file, sends its content as a response,\n    and then deletes the file from the system.\n\n    Args:\n        request (web.Request): The incoming HTTP request.\n\n    Returns:\n        web.Response: A response containing the event log content if found.\n        web.Response: A 404 response if the file is not found.\n    \"\"\"\n    logger.debug(\"Downloading events and clearing\")\n    events_file = pathlib.Path(con.EVENT_LOCATION_CSV)\n    if events_file.exists():\n        events_file_content = StringIO(events_file.read_text())\n        try:\n            return web.Response(body=events_file_content, status=200)\n        finally:\n            events_file.unlink()\n    else:\n        return web.Response(status=404, text=\"File not found\")\n</code></pre>"},{"location":"melvonaut/#melvonaut.api.get_download_telemetry","title":"<code>get_download_telemetry(request)</code>  <code>async</code>","text":"<p>Handles telemetry data download requests.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The incoming HTTP request.</p> required <p>Returns:</p> Type Description <code>Response | FileResponse</code> <p>web.Response: The telemetry file if it exists, otherwise a 404 response.</p> Source code in <code>src/melvonaut/api.py</code> <pre><code>async def get_download_telemetry(\n    request: web.Request,\n) -&gt; web.Response | web.FileResponse:\n    \"\"\"Handles telemetry data download requests.\n\n    Args:\n        request (web.Request): The incoming HTTP request.\n\n    Returns:\n        web.Response: The telemetry file if it exists, otherwise a 404 response.\n    \"\"\"\n    logger.debug(\"Downloading telemetry\")\n    telemetry_file = pathlib.Path(con.TELEMETRY_LOCATION_CSV)\n    if telemetry_file.exists():\n        return web.FileResponse(telemetry_file, status=200)\n    else:\n        return web.Response(status=404, text=\"File not found\")\n</code></pre>"},{"location":"melvonaut/#melvonaut.api.get_download_telemetry_and_clear","title":"<code>get_download_telemetry_and_clear(request)</code>  <code>async</code>","text":"<p>Handles telemetry data download requests and deletes the file after serving it.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The incoming HTTP request.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>web.Response: The telemetry file if it exists, otherwise a 404 response.</p> Source code in <code>src/melvonaut/api.py</code> <pre><code>async def get_download_telemetry_and_clear(request: web.Request) -&gt; web.Response:\n    \"\"\"Handles telemetry data download requests and deletes the file after serving it.\n\n    Args:\n        request (web.Request): The incoming HTTP request.\n\n    Returns:\n        web.Response: The telemetry file if it exists, otherwise a 404 response.\n    \"\"\"\n    logger.debug(\"Downloading telemetry and clearing\")\n    telemetry_file = pathlib.Path(con.TELEMETRY_LOCATION_CSV)\n    if telemetry_file.exists():\n        telemetry_file_content = StringIO(telemetry_file.read_text())\n        try:\n            return web.Response(body=telemetry_file_content, status=200)\n        finally:\n            telemetry_file.unlink()\n    else:\n        return web.Response(status=404, text=\"File not found\")\n</code></pre>"},{"location":"melvonaut/#melvonaut.api.get_list_images","title":"<code>get_list_images(request)</code>  <code>async</code>","text":"<p>Lists all available image files.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The incoming HTTP request.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>web.Response: JSON response containing a list of image filenames.</p> Source code in <code>src/melvonaut/api.py</code> <pre><code>async def get_list_images(request: web.Request) -&gt; web.Response:\n    \"\"\"Lists all available image files.\n\n    Args:\n        request (web.Request): The incoming HTTP request.\n\n    Returns:\n        web.Response: JSON response containing a list of image filenames.\n    \"\"\"\n    logger.debug(\"Listing images\")\n    folder = pathlib.Path(con.IMAGE_PATH_BASE)\n    if not folder.exists():\n        return web.Response(status=404, text=f\"Folder not found: {folder}\")\n    images = [str(file.name) for file in folder.rglob(\"*.png\") if file.is_file()]\n    return web.json_response({\"images\": images}, status=200)\n</code></pre>"},{"location":"melvonaut/#melvonaut.api.get_list_log_files","title":"<code>get_list_log_files(request)</code>  <code>async</code>","text":"<p>Retrieve a list of log files from the log directory.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The incoming HTTP request.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>web.Response: JSON response containing a list of log filenames.</p> Source code in <code>src/melvonaut/api.py</code> <pre><code>async def get_list_log_files(request: web.Request) -&gt; web.Response:\n    \"\"\"Retrieve a list of log files from the log directory.\n\n    Args:\n        request (web.Request): The incoming HTTP request.\n\n    Returns:\n        web.Response: JSON response containing a list of log filenames.\n    \"\"\"\n    logger.debug(\"Listing log files\")\n    log_files = []\n    folder = pathlib.Path(con.MEL_LOG_PATH)\n    try:\n        for file in folder.iterdir():\n            if not file.is_file():\n                continue\n            if not file.name.endswith(\".log\"):\n                continue\n            log_files.append(file.name)\n    except Exception as e:\n        return web.json_response({\"error\": str(e)}, status=500)\n    return web.json_response({\"log_files\": log_files}, status=200)\n</code></pre>"},{"location":"melvonaut/#melvonaut.api.get_melvin_version","title":"<code>get_melvin_version(request)</code>  <code>async</code>","text":"<p>Retrieve the current version of the Melvin service.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The incoming HTTP request.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>web.Response: JSON response containing the Melvin service version.</p> Source code in <code>src/melvonaut/api.py</code> <pre><code>async def get_melvin_version(request: web.Request) -&gt; web.Response:\n    \"\"\"Retrieve the current version of the Melvin service.\n\n    Args:\n        request (web.Request): The incoming HTTP request.\n\n    Returns:\n        web.Response: JSON response containing the Melvin service version.\n    \"\"\"\n    return web.json_response(\n        {\"version\": importlib.metadata.version(\"ciarc\")}, status=200\n    )\n</code></pre>"},{"location":"melvonaut/#melvonaut.api.get_memory_usage","title":"<code>get_memory_usage(request)</code>  <code>async</code>","text":"<p>Retrieve memory usage statistics.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The incoming HTTP request.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>web.Response: JSON response containing memory usage data.</p> Source code in <code>src/melvonaut/api.py</code> <pre><code>async def get_memory_usage(request: web.Request) -&gt; web.Response:\n    \"\"\"Retrieve memory usage statistics.\n\n    Args:\n        request (web.Request): The incoming HTTP request.\n\n    Returns:\n        web.Response: JSON response containing memory usage data.\n    \"\"\"\n    logger.debug(\"Getting memory usage\")\n    memory_usage = psutil.virtual_memory()\n    return web.json_response(memory_usage._asdict(), status=200)\n</code></pre>"},{"location":"melvonaut/#melvonaut.api.get_reset_settings","title":"<code>get_reset_settings(request)</code>  <code>async</code>","text":"<p>Resets all settings to their default values.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The incoming HTTP request.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>web.Response: A success response confirming the reset.</p> Source code in <code>src/melvonaut/api.py</code> <pre><code>async def get_reset_settings(request: web.Request) -&gt; web.Response:\n    \"\"\"Resets all settings to their default values.\n\n    Args:\n        request (web.Request): The incoming HTTP request.\n\n    Returns:\n        web.Response: A success response confirming the reset.\n    \"\"\"\n    logger.debug(\"Resetting settings\")\n    settings.clear_settings()\n    return web.Response(status=200, text=\"OK\")\n</code></pre>"},{"location":"melvonaut/#melvonaut.api.get_restart_melvin","title":"<code>get_restart_melvin(request)</code>  <code>async</code>","text":"<p>Handles a request to restart the Melvin service.</p> <p>This endpoint is not yet implemented and always returns a 501 Not Implemented response.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The incoming HTTP request.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>web.Response: A response indicating that the operation is not implemented.</p> Source code in <code>src/melvonaut/api.py</code> <pre><code>async def get_restart_melvin(request: web.Request) -&gt; web.Response:\n    \"\"\"Handles a request to restart the Melvin service.\n\n    This endpoint is not yet implemented and always returns a 501 Not Implemented response.\n\n    Args:\n        request (web.Request): The incoming HTTP request.\n\n    Returns:\n        web.Response: A response indicating that the operation is not implemented.\n    \"\"\"\n    return web.Response(status=501, text=\"Not Implemented\")\n</code></pre>"},{"location":"melvonaut/#melvonaut.api.get_shutdown_melvin","title":"<code>get_shutdown_melvin(request)</code>  <code>async</code>","text":"<p>Handles a request to shut down the Melvin service.</p> <p>If <code>settings.DO_ACTUALLY_EXIT</code> is set to True, the event loop is stopped, all pending tasks are canceled, and the process exits. Otherwise, a warning is logged.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The incoming HTTP request.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>web.Response: A response with status 200 indicating the shutdown request was received.</p> Source code in <code>src/melvonaut/api.py</code> <pre><code>async def get_shutdown_melvin(request: web.Request) -&gt; web.Response:\n    \"\"\"Handles a request to shut down the Melvin service.\n\n    If `settings.DO_ACTUALLY_EXIT` is set to True, the event loop is stopped,\n    all pending tasks are canceled, and the process exits. Otherwise, a warning is logged.\n\n    Args:\n        request (web.Request): The incoming HTTP request.\n\n    Returns:\n        web.Response: A response with status 200 indicating the shutdown request was received.\n    \"\"\"\n    try:\n        return web.Response(status=200, text=\"OK\")\n    finally:\n        if settings.DO_ACTUALLY_EXIT:\n            loop = asyncio.get_running_loop()\n            loop.stop()\n            pending_tasks = asyncio.all_tasks()\n            for task in pending_tasks:\n                task.cancel()\n            exit()\n        else:\n            logger.warning(\"Requested shutdown, but not actually exiting\")\n</code></pre>"},{"location":"melvonaut/#melvonaut.api.health","title":"<code>health(request)</code>  <code>async</code>","text":"<p>Check if the API is running and healthy.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The incoming HTTP request.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>web.Response: A response with status 200 and text \"OK\".</p> Source code in <code>src/melvonaut/api.py</code> <pre><code>async def health(request: web.Request) -&gt; web.Response:\n    \"\"\"Check if the API is running and healthy.\n\n    Args:\n        request (web.Request): The incoming HTTP request.\n\n    Returns:\n        web.Response: A response with status 200 and text \"OK\".\n    \"\"\"\n    return web.Response(status=200, text=\"OK\")\n</code></pre>"},{"location":"melvonaut/#melvonaut.api.post_clear_log","title":"<code>post_clear_log(request)</code>  <code>async</code>","text":"<p>Handles log file deletion requests.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The incoming HTTP request containing the log file name in JSON format.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>web.Response: A success response if the log file is cleared, otherwise an error response.</p> Source code in <code>src/melvonaut/api.py</code> <pre><code>async def post_clear_log(request: web.Request) -&gt; web.Response:\n    \"\"\"Handles log file deletion requests.\n\n    Args:\n        request (web.Request): The incoming HTTP request containing the log file name in JSON format.\n\n    Returns:\n        web.Response: A success response if the log file is cleared, otherwise an error response.\n    \"\"\"\n    data = await request.json()\n    logger.debug(f\"Clearing log: {data}\")\n    log_file = pathlib.Path(con.MEL_LOG_PATH) / data.get(\"file\")\n    if log_file.exists():\n        if log_file.is_dir():\n            return web.Response(status=400, text=f\"{log_file} is a directory\")\n        if not log_file.name.endswith(\".log\"):\n            return web.Response(status=400, text=f\"{log_file} is not a log file\")\n        log_file.unlink()\n        utils.setup_file_logging()\n        return web.Response(status=200, text=f\"{log_file} cleared\")\n    else:\n        return web.Response(status=404, text=f\"{log_file} not found\")\n</code></pre>"},{"location":"melvonaut/#melvonaut.api.post_clear_setting","title":"<code>post_clear_setting(request)</code>  <code>async</code>","text":"<p>Clears a specific setting.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The incoming HTTP request containing the setting name in JSON format.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>web.Response: A success response if the setting is cleared.</p> Source code in <code>src/melvonaut/api.py</code> <pre><code>async def post_clear_setting(request: web.Request) -&gt; web.Response:\n    \"\"\"Clears a specific setting.\n\n    Args:\n        request (web.Request): The incoming HTTP request containing the setting name in JSON format.\n\n    Returns:\n        web.Response: A success response if the setting is cleared.\n    \"\"\"\n    logger.debug(\"Clearing settings\")\n    data = await request.json()\n    logger.debug(f\"Clearing settings: {data}\")\n    settings.delete_settings(data.keys())\n    return web.Response(status=200, text=\"OK\")\n</code></pre>"},{"location":"melvonaut/#melvonaut.api.post_download_image","title":"<code>post_download_image(request)</code>  <code>async</code>","text":"<p>Handles image file download requests.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The incoming HTTP request containing the image filename in JSON format.</p> required <p>Returns:</p> Type Description <code>Response | FileResponse</code> <p>web.Response: The requested image file if it exists, otherwise a 404 response.</p> Source code in <code>src/melvonaut/api.py</code> <pre><code>async def post_download_image(request: web.Request) -&gt; web.Response | web.FileResponse:\n    \"\"\"Handles image file download requests.\n\n    Args:\n        request (web.Request): The incoming HTTP request containing the image filename in JSON format.\n\n    Returns:\n        web.Response: The requested image file if it exists, otherwise a 404 response.\n    \"\"\"\n    data = await request.json()\n    logger.debug(f\"Downloading image: {data}\")\n    image_file = pathlib.Path(con.IMAGE_PATH_BASE) / data.get(\"file\")\n    if image_file.exists():\n        return web.FileResponse(image_file, status=200)\n    else:\n        return web.Response(status=404, text=\"File not found\")\n</code></pre>"},{"location":"melvonaut/#melvonaut.api.post_download_image_and_clear","title":"<code>post_download_image_and_clear(request)</code>  <code>async</code>","text":"<p>Handles image file download requests and deletes the file after serving it.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The incoming HTTP request containing the image filename in JSON format.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>web.Response: The requested image file if it exists, otherwise a 404 response.</p> Source code in <code>src/melvonaut/api.py</code> <pre><code>async def post_download_image_and_clear(request: web.Request) -&gt; web.Response:\n    \"\"\"Handles image file download requests and deletes the file after serving it.\n\n    Args:\n        request (web.Request): The incoming HTTP request containing the image filename in JSON format.\n\n    Returns:\n        web.Response: The requested image file if it exists, otherwise a 404 response.\n    \"\"\"\n    data = await request.json()\n    logger.debug(f\"Downloading image and clearing: {data}\")\n    image_file = pathlib.Path(con.IMAGE_PATH_BASE) / data.get(\"file\")\n    if image_file.exists():\n        image_file_content = BytesIO(image_file.read_bytes())\n        try:\n            return web.Response(body=image_file_content, status=200)\n        finally:\n            image_file.unlink()\n    else:\n        return web.Response(status=404, text=\"File not found\")\n</code></pre>"},{"location":"melvonaut/#melvonaut.api.post_download_log","title":"<code>post_download_log(request)</code>  <code>async</code>","text":"<p>Handles log file download requests.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The incoming HTTP request containing the log file name in JSON format.</p> required <p>Returns:</p> Type Description <code>Response | FileResponse</code> <p>web.Response: The requested log file if it exists, otherwise a 404 response.</p> Source code in <code>src/melvonaut/api.py</code> <pre><code>async def post_download_log(request: web.Request) -&gt; web.Response | web.FileResponse:\n    \"\"\"Handles log file download requests.\n\n    Args:\n        request (web.Request): The incoming HTTP request containing the log file name in JSON format.\n\n    Returns:\n        web.Response: The requested log file if it exists, otherwise a 404 response.\n    \"\"\"\n    data = await request.json()\n    logger.debug(f\"Downloading log: {data}\")\n    log_file = pathlib.Path(con.MEL_LOG_PATH) / data.get(\"file\")\n    if log_file.exists():\n        return web.FileResponse(log_file, status=200)\n    else:\n        return web.Response(status=404, text=\"File not found\")\n</code></pre>"},{"location":"melvonaut/#melvonaut.api.post_download_log_and_clear","title":"<code>post_download_log_and_clear(request)</code>  <code>async</code>","text":"<p>Handles log file download requests and deletes the file after serving it.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The incoming HTTP request containing the log file name in JSON format.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>web.Response: The requested log file if it exists, otherwise a 404 response.</p> Source code in <code>src/melvonaut/api.py</code> <pre><code>async def post_download_log_and_clear(request: web.Request) -&gt; web.Response:\n    \"\"\"Handles log file download requests and deletes the file after serving it.\n\n    Args:\n        request (web.Request): The incoming HTTP request containing the log file name in JSON format.\n\n    Returns:\n        web.Response: The requested log file if it exists, otherwise a 404 response.\n    \"\"\"\n    data = await request.json()\n    logger.debug(f\"Downloading log and clearing: {data}\")\n    log_file = pathlib.Path(con.MEL_LOG_PATH) / data.get(\"file\")\n    if log_file.exists():\n        log_file_content = StringIO(log_file.read_text())\n        try:\n            return web.Response(body=log_file_content, status=200)\n        finally:\n            log_file.unlink()\n            utils.setup_file_logging()\n    else:\n        return web.Response(status=404, text=\"File not found\")\n</code></pre>"},{"location":"melvonaut/#melvonaut.api.post_execute_command","title":"<code>post_execute_command(request)</code>  <code>async</code>","text":"<p>Execute a shell command asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The incoming HTTP request containing JSON data with the command to execute.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>web.Response: JSON response containing command output and return code.</p> Source code in <code>src/melvonaut/api.py</code> <pre><code>async def post_execute_command(request: web.Request) -&gt; web.Response:\n    \"\"\"Execute a shell command asynchronously.\n\n    Args:\n        request (web.Request): The incoming HTTP request containing JSON data with the command to execute.\n\n    Returns:\n        web.Response: JSON response containing command output and return code.\n    \"\"\"\n    data = await request.json()\n    cmd = data.get(\"cmd\")\n    logger.debug(f\"Executing command: {cmd}\")\n    output = []\n    try:\n        process = await asyncio.create_subprocess_shell(\n            cmd, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE\n        )\n        while True:\n            if process.stdout:\n                line = await process.stdout.readline()\n                if not line:\n                    break\n                output.append(line.decode())\n        await process.wait()\n        return_code = process.returncode\n        logger.debug(f\"Command output: {output}\")\n        return web.json_response(\n            {\"output\": output, \"return_code\": return_code}, status=200\n        )\n    except asyncio.TimeoutError:\n        return web.json_response({\"output\": output, \"error\": \"Timeout\"}, status=500)\n    except asyncio.CancelledError:\n        return web.json_response({\"output\": output, \"error\": \"Cancelled\"}, status=500)\n    except Exception as e:\n        return web.json_response({\"output\": output, \"error\": str(e)}, status=500)\n</code></pre>"},{"location":"melvonaut/#melvonaut.api.post_get_setting","title":"<code>post_get_setting(request)</code>  <code>async</code>","text":"<p>Retrieves a specific setting.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The incoming HTTP request containing the setting name in JSON format.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>web.Response: JSON response containing the requested setting value.</p> Source code in <code>src/melvonaut/api.py</code> <pre><code>async def post_get_setting(request: web.Request) -&gt; web.Response:\n    \"\"\"Retrieves a specific setting.\n\n    Args:\n        request (web.Request): The incoming HTTP request containing the setting name in JSON format.\n\n    Returns:\n        web.Response: JSON response containing the requested setting value.\n    \"\"\"\n    logger.debug(\"Getting settings\")\n    data = await request.json()\n    logger.debug(f\"Requested settings: {data}\")\n    response_settings = {}\n    try:\n        for key in data.keys():\n            response_settings[key] = settings.__getattribute__(key)\n    except AttributeError:\n        return web.Response(status=404, text=f\"Setting not found: {key}\")\n    logger.debug(f\"Response settings: {response_settings}\")\n    return web.json_response(response_settings, status=200)\n</code></pre>"},{"location":"melvonaut/#melvonaut.api.post_set_melvin_task","title":"<code>post_set_melvin_task(request)</code>  <code>async</code>","text":"<p>Sets a task for Melvin (a task management system).</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The incoming HTTP request containing the task details in JSON format.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>web.Response: A success response if the task is set.</p> Source code in <code>src/melvonaut/api.py</code> <pre><code>async def post_set_melvin_task(request: web.Request) -&gt; web.Response:\n    \"\"\"Sets a task for Melvin (a task management system).\n\n    Args:\n        request (web.Request): The incoming HTTP request containing the task details in JSON format.\n\n    Returns:\n        web.Response: A success response if the task is set.\n    \"\"\"\n    data = await request.json()\n    logger.debug(f\"Setting melvin task: {data}\")\n    task = data.get(\"task\", None)\n    if not task:\n        logger.warning(\"Missing field task\")\n        return web.Response(status=400, text=\"Missing field task\")\n    try:\n        melvin_task = models.MELVINTask(task)\n    except ValueError:\n        logger.warning(\"Invalid task\")\n        return web.Response(status=400, text=\"Invalid task\")\n    except Exception as e:\n        logger.warning(f\"Error setting melvin task: {e}\")\n        return web.Response(status=500, text=str(e))\n    settings.set_settings({\"CURRENT_MELVIN_TASK\": melvin_task})\n    return web.Response(status=200, text=\"OK\")\n</code></pre>"},{"location":"melvonaut/#melvonaut.api.post_set_setting","title":"<code>post_set_setting(request)</code>  <code>async</code>","text":"<p>Sets a new configuration setting.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The incoming HTTP request containing settings in JSON format.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>web.Response: A success response if the setting is applied.</p> Source code in <code>src/melvonaut/api.py</code> <pre><code>async def post_set_setting(request: web.Request) -&gt; web.Response:\n    \"\"\"Sets a new configuration setting.\n\n    Args:\n        request (web.Request): The incoming HTTP request containing settings in JSON format.\n\n    Returns:\n        web.Response: A success response if the setting is applied.\n    \"\"\"\n    logger.debug(\"Setting settings\")\n    data = await request.json()\n    logger.debug(f\"Setting settings: {data}\")\n    settings.set_settings(data)\n    return web.Response(status=200, text=\"OK\")\n</code></pre>"},{"location":"melvonaut/#melvonaut.api.run_api","title":"<code>run_api()</code>  <code>async</code>","text":"<p>Starts the web API server.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/melvonaut/api.py</code> <pre><code>async def run_api() -&gt; None:\n    \"\"\"Starts the web API server.\n\n    Returns:\n        None\n    \"\"\"\n    logger.debug(\"Setting up API server\")\n    settings.init_settings()\n    app = web.Application(middlewares=[compression_middleware, catcher_middleware])\n    setup_routes(app)\n    runner = web.AppRunner(app)\n    await runner.setup()\n    site = web.TCPSite(runner, \"0.0.0.0\", settings.API_PORT)\n    try:\n        logger.info(f\"API server started on port {settings.API_PORT}\")\n        await site.start()\n        logger.debug(\"API server started\")\n    finally:\n        # das hat bei mir direkt nach dem start ausgel\u00f6st\n        # logger.debug(\"Shutting down API server\")\n        # await runner.cleanup()\n        pass\n</code></pre>"},{"location":"melvonaut/#melvonaut.api.setup_routes","title":"<code>setup_routes(app)</code>","text":"<p>Sets up API routes for the web application.</p> <p>Parameters:</p> Name Type Description Default <code>app</code> <code>Application</code> <p>The web application instance.</p> required Source code in <code>src/melvonaut/api.py</code> <pre><code>def setup_routes(app: web.Application) -&gt; None:\n    \"\"\"Sets up API routes for the web application.\n\n    Args:\n        app (web.Application): The web application instance.\n    \"\"\"\n    app.router.add_post(\"/api/post_download_log\", post_download_log)\n    app.router.add_get(\"/api/get_download_telemetry\", get_download_telemetry)\n    app.router.add_get(\"/api/get_download_events\", get_download_events)\n    app.router.add_post(\"/api/post_download_image\", post_download_image)\n    app.router.add_post(\"/api/post_set_melvin_task\", post_set_melvin_task)\n    app.router.add_get(\"/api/get_reset_settings\", get_reset_settings)\n    app.router.add_post(\"/api/post_set_setting\", post_set_setting)\n    app.router.add_post(\"/api/post_clear_setting\", post_clear_setting)\n    app.router.add_post(\"/api/post_clear_log\", post_clear_log)\n    app.router.add_post(\"/api/post_get_setting\", post_get_setting)\n    app.router.add_get(\"/api/get_all_settings\", get_all_settings)\n    app.router.add_post(\"/api/post_download_log_and_clear\", post_download_log_and_clear)\n    app.router.add_get(\n        \"/api/get_download_telemetry_and_clear\", get_download_telemetry_and_clear\n    )\n    app.router.add_get(\n        \"/api/get_download_events_and_clear\", get_download_events_and_clear\n    )\n    app.router.add_post(\n        \"/api/post_download_image_and_clear\", post_download_image_and_clear\n    )\n    app.router.add_get(\"/api/get_clear_all_logs\", get_clear_all_logs)\n    app.router.add_get(\"/api/get_clear_telemetry\", get_clear_telemetry)\n    app.router.add_get(\"/api/get_clear_events\", get_clear_events)\n    app.router.add_get(\"/api/get_clear_all_images\", get_clear_all_images)\n    app.router.add_get(\"/api/health\", health)\n    app.router.add_get(\"/api/get_disk_usage\", get_disk_usage)\n    app.router.add_get(\"/api/get_memory_usage\", get_memory_usage)\n    app.router.add_get(\"/api/get_cpu_usage\", get_cpu_usage)\n    app.router.add_get(\"/api/get_restart_melvin\", get_restart_melvin)\n    app.router.add_get(\"/api/get_shutdown_melvin\", get_shutdown_melvin)\n    app.router.add_post(\"/api/post_execute_command\", post_execute_command)\n    app.router.add_get(\"/api/get_melvin_version\", get_melvin_version)\n    app.router.add_get(\"/api/get_list_log_files\", get_list_log_files)\n    app.router.add_get(\"/api/get_list_images\", get_list_images)\n</code></pre>"},{"location":"melvonaut/#melvonaut.ebt_calc","title":"<code>ebt_calc</code>","text":""},{"location":"melvonaut/#melvonaut.ebt_calc.events","title":"<code>events = Event.load_events_from_csv(path=path)</code>  <code>module-attribute</code>","text":"<p>processed = []</p>"},{"location":"melvonaut/#melvonaut.ebt_calc.events--data-4097-7652-2041-5758-8357-688-6220-8553-1075-7245-8989-1669","title":"data = [(4097, 7652, 2041), (5758, 8357, 688), (6220, 8553, 1075), (7245, 8989, 1669)]","text":"<p>data = [     (19972.3165561, 113.5243816, 1454.48),     (20486.232864, 331.337984, 930.35),     (20998.9861724, 548.6578144, 787.93),     (21510.18207954, 766.74099024, 1093.99),     (18882.99334624, 2295.73420544, 1947.67),     (19394.53293776, 2512.96329856, 1450.01),     (19908.73421827, 2730.89789112, 1442.63),     (20421.30728271, 2948.14119576, 1828.68),     (20926.46189231, 3163.05597336, 1651.83), ] for d in data:     s = ping(         x=int(d[0] / scaling_factor),         y=int(d[1] / scaling_factor),         d=d[2] / scaling_factor,         mind=int((d[2] - max_offset) / scaling_factor),         maxd=int((d[2] + max_offset) / scaling_factor),     )     processed.append(s)     print(f\"Added: {s}\")</p>"},{"location":"melvonaut/#melvonaut.ebt_calc.id","title":"<code>id = 201</code>  <code>module-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.ebt_calc.max_offset","title":"<code>max_offset = 325</code>  <code>module-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.ebt_calc.path","title":"<code>path = con.CONSOLE_FROM_MELVONAUT_PATH + 'MelvonautEvents.csv'</code>  <code>module-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.ebt_calc.processed","title":"<code>processed = parse_pings(id=id, events=events)</code>  <code>module-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.ebt_calc.res","title":"<code>res = find_matches(pings=processed)</code>  <code>module-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.ebt_calc.scaling_factor","title":"<code>scaling_factor = 1</code>  <code>module-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.ebt_calc.x_0","title":"<code>x_0 = 0</code>  <code>module-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.ebt_calc.x_max","title":"<code>x_max = int(con.WORLD_X / scaling_factor)</code>  <code>module-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.ebt_calc.y_0","title":"<code>y_0 = 0</code>  <code>module-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.ebt_calc.y_max","title":"<code>y_max = int(con.WORLD_Y / scaling_factor)</code>  <code>module-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.ebt_calc.distance","title":"<code>distance(x1, x2, y1, y2)</code>","text":"<p>Computes the Euclidean distance between two points, adjusting for wraparound conditions.</p> <p>Parameters:</p> Name Type Description Default <code>x1</code> <code>int</code> <p>X-coordinate of the first point.</p> required <code>x2</code> <code>int</code> <p>X-coordinate of the second point.</p> required <code>y1</code> <code>int</code> <p>Y-coordinate of the first point.</p> required <code>y2</code> <code>int</code> <p>Y-coordinate of the second point.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The Euclidean distance between the two points.</p> Source code in <code>src/melvonaut/ebt_calc.py</code> <pre><code>def distance(x1: int, x2: int, y1: int, y2: int) -&gt; float:\n    \"\"\"\n    Computes the Euclidean distance between two points, adjusting for wraparound conditions.\n\n    Args:\n        x1 (int): X-coordinate of the first point.\n        x2 (int): X-coordinate of the second point.\n        y1 (int): Y-coordinate of the first point.\n        y2 (int): Y-coordinate of the second point.\n\n    Returns:\n        float: The Euclidean distance between the two points.\n    \"\"\"\n    if x1 &gt; con.WORLD_X:\n        x1 = x1 % con.WORLD_X\n    while x1 &lt; 0:\n        x1 += con.WORLD_X\n    if y1 &gt; con.WORLD_Y:\n        y1 = y1 % con.WORLD_Y\n    while y1 &lt; 0:\n        y1 += con.WORLD_Y\n    if x2 &gt; con.WORLD_X:\n        x2 = x2 % con.WORLD_X\n    while x2 &lt; 0:\n        x2 += con.WORLD_X\n    if y2 &gt; con.WORLD_Y:\n        y2 = y2 % con.WORLD_Y\n    while y2 &lt; 0:\n        y2 += con.WORLD_Y\n\n    # check for case at edge\n    a = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n    b = math.sqrt((con.WORLD_X + x2 - x1) ** 2 + (y2 - y1) ** 2)\n    c = math.sqrt((x2 - x1 - con.WORLD_X) ** 2 + (y2 - y1) ** 2)\n    d = math.sqrt((x2 - x1) ** 2 + (con.WORLD_Y + y2 - y1) ** 2)\n    e = math.sqrt((x2 - x1) ** 2 + (y2 - y1 - con.WORLD_Y) ** 2)\n    return min(a, b, c, d, e)\n</code></pre>"},{"location":"melvonaut/#melvonaut.ebt_calc.draw_res","title":"<code>draw_res(id, res, pings, show=False)</code>","text":"<p>Draws and saves a visualization of the computed emergency beacon locations.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>Identifier for the emergency beacon tracker.</p> required <code>res</code> <code>list[tuple[int, int]]</code> <p>List of matched coordinate points.</p> required <code>pings</code> <code>list[Ping]</code> <p>List of Ping objects representing detected signals.</p> required <code>show</code> <code>bool</code> <p>Whether to display the plot. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple[int, int]</code> <p>tuple[int, int]: The estimated centroid of the matched points, or (-1, -1) if no matches were found.</p> Source code in <code>src/melvonaut/ebt_calc.py</code> <pre><code>def draw_res(\n    id: int, res: list[tuple[int, int]], pings: list[Ping], show: bool = False\n) -&gt; tuple[int, int]:\n    \"\"\"\n    Draws and saves a visualization of the computed emergency beacon locations.\n\n    Args:\n        id (int): Identifier for the emergency beacon tracker.\n        res (list[tuple[int, int]]): List of matched coordinate points.\n        pings (list[Ping]): List of Ping objects representing detected signals.\n        show (bool, optional): Whether to display the plot. Defaults to False.\n\n    Returns:\n        tuple[int, int]: The estimated centroid of the matched points, or (-1, -1) if no matches were found.\n    \"\"\"\n\n    def find_centroid(points: list[tuple[int, int]]) -&gt; tuple[float, float]:\n        \"\"\"\n        Computes the centroid of a set of points.\n\n        Args:\n            points (list[tuple[int, int]]): List of coordinate points.\n\n        Returns:\n            tuple[float, float]: The centroid coordinates.\n        \"\"\"\n        xs, ys = zip(*points)\n        centroid_x = sum(xs) / len(xs)\n        centroid_y = sum(ys) / len(ys)\n        return (centroid_x, centroid_y)\n\n    x_list, y_list = [], []\n    for x, y in res:\n        x_list.append(x)\n        y_list.append(y)\n\n    if res:\n        centroid = find_centroid(res)\n\n    plt.style.use(\"bmh\")\n    _, ax = plt.subplots()\n    plt.title(f\"Emergency Beacon Tracker {id} - {len(pings)} pings\")\n    plt.xlabel(\"Width\")\n    plt.ylabel(\"Height\")\n    ax.set_xlim(0, x_max)\n    ax.set_ylim(0, y_max)\n\n    # plot matched area\n    ax.plot(x_list, y_list, \"ro\", markersize=0.01, zorder=4)\n    legend_area = patches.Patch(\n        edgecolor=\"red\", facecolor=\"red\", linewidth=1, label=\"Matched area\"\n    )\n\n    # plot pings\n    for p in pings:\n        ax.plot(p.x, p.y, \"x\", color=\"grey\", markersize=5, zorder=3)\n        circle_inner = patches.Circle(\n            (p.x, p.y),\n            p.mind,\n            edgecolor=\"green\",\n            facecolor=\"none\",\n            linewidth=0.2,\n            zorder=2,\n        )\n        circle_outer = patches.Circle(\n            (p.x, p.y),\n            p.maxd,\n            edgecolor=\"blue\",\n            facecolor=\"none\",\n            linewidth=0.2,\n            zorder=2,\n        )\n        ax.add_patch(circle_inner)\n        ax.add_patch(circle_outer)\n    legend_point = Line2D(\n        [0],\n        [0],\n        linestyle=\"None\",\n        marker=\"x\",\n        markerfacecolor=\"grey\",\n        markeredgecolor=\"grey\",\n        markersize=6,\n        label=\"Ping Location\",\n    )\n    legend_inner = patches.Patch(\n        edgecolor=\"green\", facecolor=\"none\", linewidth=1, label=\"Minimum Distance\"\n    )\n    legend_outer = patches.Patch(\n        edgecolor=\"blue\", facecolor=\"none\", linewidth=1, label=\"Maximum Distance\"\n    )\n\n    if res:\n        # plot centroid\n        circle_guess = patches.Circle(\n            (centroid[0], centroid[1]),\n            75,\n            edgecolor=\"violet\",\n            facecolor=\"violet\",\n            linewidth=1,\n            zorder=5,\n        )\n        ax.add_patch(circle_guess)\n        legend_guess = patches.Patch(\n            edgecolor=\"violet\",\n            facecolor=\"violet\",\n            linewidth=1,\n            label=f\"Best guess\\n({int(centroid[0])}, {int(centroid[1])})\",\n        )\n        ax.legend(\n            handles=[\n                legend_point,\n                legend_inner,\n                legend_outer,\n                legend_guess,\n                legend_area,\n            ],\n            loc=\"best\",\n        )\n    else:\n        ax.legend(\n            handles=[legend_point, legend_inner, legend_outer, legend_area],\n            loc=\"best\",\n        )\n\n    if show:\n        if res:\n            logger.info(f\"Centroid is: ({int(centroid[0])},{int(centroid[1])})\")\n        else:\n            logger.warning(\"Could not match any points!\")\n        plt.show()\n    else:\n        space = \"\"\n        count = 0\n        path = con.CONSOLE_EBT_PATH + f\"EBT_{id}_{len(pings)}.png\"\n        while os.path.isfile(path):\n            count += 1\n            space = \"_\" + str(count)\n            path = con.CONSOLE_EBT_PATH + f\"EBT_{id}_{len(pings)}{space}.png\"\n        plt.savefig(path, dpi=1000)\n    if res:\n        return (int(centroid[0]), int(centroid[1]))\n    else:\n        return (-1, -1)\n</code></pre>"},{"location":"melvonaut/#melvonaut.ebt_calc.f","title":"<code>f(d)</code>","text":"<p>Computes a transformed distance value.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>float</code> <p>Input distance value.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Transformed distance value.</p> Source code in <code>src/melvonaut/ebt_calc.py</code> <pre><code>def f(d: float) -&gt; float:\n    \"\"\"\n    Computes a transformed distance value.\n\n    Args:\n        d (float): Input distance value.\n\n    Returns:\n        float: Transformed distance value.\n    \"\"\"\n    res = 225 + ((0.4 * (d + 1)) / 4)\n    return float(res)\n</code></pre>"},{"location":"melvonaut/#melvonaut.ebt_calc.find_matches","title":"<code>find_matches(pings)</code>","text":"<p>Identifies matching points from the given pings based on distance constraints.</p> <p>Parameters:</p> Name Type Description Default <code>pings</code> <code>list[Ping]</code> <p>List of Ping objects to process.</p> required <p>Returns:</p> Type Description <code>list[tuple[int, int]]</code> <p>list[tuple[int, int]]: List of coordinate pairs that satisfy all constraints.</p> Source code in <code>src/melvonaut/ebt_calc.py</code> <pre><code>def find_matches(pings: list[Ping]) -&gt; list[tuple[int, int]]:\n    \"\"\"\n    Identifies matching points from the given pings based on distance constraints.\n\n    Args:\n        pings (list[Ping]): List of Ping objects to process.\n\n    Returns:\n        list[tuple[int, int]]: List of coordinate pairs that satisfy all constraints.\n    \"\"\"\n    # Procssed first point\n    res = []\n    p1 = min(pings, key=lambda p: p.maxd)\n    for x in range(p1.x - p1.maxd, p1.x + p1.maxd):\n        for y in range(p1.y - p1.maxd, p1.y + p1.maxd):\n            if x &gt; x_0 and x &lt; x_max and y &gt; y_0 and y &lt; y_max:\n                dist = distance(p1.x, x, p1.y, y)\n                if dist &gt; p1.mind and dist &lt; p1.maxd:\n                    res.append((x, y))\n    logger.info(f\"Found {len(res)} possible points on first circle.\")\n\n    # Only keep the ones that are in all circles\n    filtered_res = []\n    for x, y in res:\n        is_valid = True\n        for pn in pings:\n            dist = distance(pn.x, x, pn.y, y)\n            if dist &lt; pn.mind or dist &gt; pn.maxd:\n                is_valid = False\n                break\n        if is_valid:\n            filtered_res.append((x, y))\n\n    logger.info(f\"Found {len(filtered_res)} points that match all pings.\")\n    return filtered_res\n</code></pre>"},{"location":"melvonaut/#melvonaut.ebt_calc.parse_pings","title":"<code>parse_pings(id, events)</code>","text":"<p>Parses event data to extract relevant ping information.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>int</code> <p>Identifier for the event source.</p> required <code>events</code> <code>list[Event]</code> <p>List of event objects to be processed.</p> required <p>Returns:</p> Type Description <code>list[Ping]</code> <p>list[Ping]: A list of parsed Ping objects.</p> Source code in <code>src/melvonaut/ebt_calc.py</code> <pre><code>def parse_pings(id: int, events: list[Event]) -&gt; list[Ping]:\n    \"\"\"\n    Parses event data to extract relevant ping information.\n\n    Args:\n        id (int): Identifier for the event source.\n        events (list[Event]): List of event objects to be processed.\n\n    Returns:\n        list[Ping]: A list of parsed Ping objects.\n    \"\"\"\n    processed = []\n    for event in events:\n        if f\"GALILEO_MSG_EB,ID_{id},DISTANCE_\" in event.event:\n            (d, x, y) = event.easy_parse()\n            s = Ping(\n                x=int(x / scaling_factor),\n                y=int(y / scaling_factor),\n                d=d / scaling_factor,\n                mind=int((d - f(d)) / scaling_factor),\n                maxd=int((d + f(d)) / scaling_factor),\n            )\n            processed.append(s)\n    return processed\n</code></pre>"},{"location":"melvonaut/#melvonaut.mel_telemetry","title":"<code>mel_telemetry</code>","text":""},{"location":"melvonaut/#melvonaut.mel_telemetry.MelTelemetry","title":"<code>MelTelemetry</code>","text":"<p>               Bases: <code>BaseTelemetry</code></p> Source code in <code>src/melvonaut/mel_telemetry.py</code> <pre><code>class MelTelemetry(BaseTelemetry):\n    timestamp: datetime.datetime\n\n    async def store_observation_csv(self) -&gt; None:\n        \"\"\"\n        Stores the telemetry observation data in a CSV file.\n\n        This function converts the telemetry data into a flattened dictionary format,\n        ensuring nested dictionaries are stored as separate fields. It then appends\n        the data to an existing CSV file or creates a new file if one does not exist.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n        tel_dict = self.model_dump()\n        flattened = {}\n        for key, value in tel_dict.items():\n            if isinstance(value, dict):\n                for sub_key, sub_value in value.items():\n                    flattened[f\"{key}_{sub_key}\"] = sub_value\n            else:\n                flattened[key] = value\n        if self.timestamp:\n            timestamp = self.timestamp.isoformat()\n        else:\n            timestamp = datetime.datetime.now().isoformat()\n        flattened[\"timestamp\"] = timestamp\n\n        if not Path(con.TELEMETRY_LOCATION_CSV).is_file():\n            async with async_open(con.TELEMETRY_LOCATION_CSV, \"w\") as afp:\n                writer = csv.DictWriter(afp, fieldnames=flattened.keys())\n                await writer.writeheader()\n                await writer.writerow(flattened)\n            # logger.debug(f\"Writing observation to {con.TELEMETRY_LOCATION_CSV}\")\n        else:\n            async with async_open(con.TELEMETRY_LOCATION_CSV, \"a\") as afp:\n                writer = csv.DictWriter(afp, fieldnames=flattened.keys())\n                await writer.writerow(flattened)\n            # logger.debug(f\"Writing observation to {con.TELEMETRY_LOCATION_CSV}\")\n\n    async def store_observation_json(self) -&gt; None:\n        \"\"\"\n        Stores the telemetry observation data in a JSON file.\n\n        This function retrieves the existing telemetry data from the JSON file\n        and updates it with a new entry. If the JSON file does not exist, a new\n        one is created. The data is formatted in a structured manner with timestamps\n        as keys.\n\n        Args:\n            None\n\n        Returns:\n            None\n        \"\"\"\n        logger.debug(\"Storing observation as json.\")\n        try:\n            async with async_open(con.TELEMETRY_LOCATION_JSON, \"r\") as afp:\n                raw_telemetry = await afp.read()\n                dict_telemetry = json.loads(raw_telemetry)\n        except FileNotFoundError:\n            logger.debug(f\"{con.TELEMETRY_LOCATION_JSON} does not exist.\")\n            dict_telemetry = {}\n\n        if self.timestamp:\n            timestamp = self.timestamp.isoformat()\n        else:\n            timestamp = datetime.datetime.now().isoformat()\n        new_telemetry_entry = self.model_dump(exclude={\"timestamp\"})\n        dict_telemetry[timestamp] = new_telemetry_entry\n        json_telemetry = json.dumps(dict_telemetry, indent=4, sort_keys=True)\n\n        async with async_open(con.TELEMETRY_LOCATION_JSON, \"w\") as afp:\n            # logger.debug(f\"Writing to {con.TELEMETRY_LOCATION_JSON}\")\n            await afp.write(str(json_telemetry))\n        logger.debug(\"Observation stored\")\n\n    def model_post_init(self, __context__: Any) -&gt; None:\n        \"\"\"\n        Initializes the telemetry model and triggers CSV storage.\n\n        Args:\n            __context__ (Any): Context data passed during initialization.\n\n        Returns:\n            None\n        \"\"\"\n        loop = asyncio.get_event_loop()\n        loop.create_task(self.store_observation_csv())\n</code></pre>"},{"location":"melvonaut/#melvonaut.mel_telemetry.MelTelemetry.timestamp","title":"<code>timestamp</code>  <code>instance-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.mel_telemetry.MelTelemetry.model_post_init","title":"<code>model_post_init(__context__)</code>","text":"<p>Initializes the telemetry model and triggers CSV storage.</p> <p>Parameters:</p> Name Type Description Default <code>__context__</code> <code>Any</code> <p>Context data passed during initialization.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/melvonaut/mel_telemetry.py</code> <pre><code>def model_post_init(self, __context__: Any) -&gt; None:\n    \"\"\"\n    Initializes the telemetry model and triggers CSV storage.\n\n    Args:\n        __context__ (Any): Context data passed during initialization.\n\n    Returns:\n        None\n    \"\"\"\n    loop = asyncio.get_event_loop()\n    loop.create_task(self.store_observation_csv())\n</code></pre>"},{"location":"melvonaut/#melvonaut.mel_telemetry.MelTelemetry.store_observation_csv","title":"<code>store_observation_csv()</code>  <code>async</code>","text":"<p>Stores the telemetry observation data in a CSV file.</p> <p>This function converts the telemetry data into a flattened dictionary format, ensuring nested dictionaries are stored as separate fields. It then appends the data to an existing CSV file or creates a new file if one does not exist.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/melvonaut/mel_telemetry.py</code> <pre><code>async def store_observation_csv(self) -&gt; None:\n    \"\"\"\n    Stores the telemetry observation data in a CSV file.\n\n    This function converts the telemetry data into a flattened dictionary format,\n    ensuring nested dictionaries are stored as separate fields. It then appends\n    the data to an existing CSV file or creates a new file if one does not exist.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    tel_dict = self.model_dump()\n    flattened = {}\n    for key, value in tel_dict.items():\n        if isinstance(value, dict):\n            for sub_key, sub_value in value.items():\n                flattened[f\"{key}_{sub_key}\"] = sub_value\n        else:\n            flattened[key] = value\n    if self.timestamp:\n        timestamp = self.timestamp.isoformat()\n    else:\n        timestamp = datetime.datetime.now().isoformat()\n    flattened[\"timestamp\"] = timestamp\n\n    if not Path(con.TELEMETRY_LOCATION_CSV).is_file():\n        async with async_open(con.TELEMETRY_LOCATION_CSV, \"w\") as afp:\n            writer = csv.DictWriter(afp, fieldnames=flattened.keys())\n            await writer.writeheader()\n            await writer.writerow(flattened)\n        # logger.debug(f\"Writing observation to {con.TELEMETRY_LOCATION_CSV}\")\n    else:\n        async with async_open(con.TELEMETRY_LOCATION_CSV, \"a\") as afp:\n            writer = csv.DictWriter(afp, fieldnames=flattened.keys())\n            await writer.writerow(flattened)\n</code></pre>"},{"location":"melvonaut/#melvonaut.mel_telemetry.MelTelemetry.store_observation_json","title":"<code>store_observation_json()</code>  <code>async</code>","text":"<p>Stores the telemetry observation data in a JSON file.</p> <p>This function retrieves the existing telemetry data from the JSON file and updates it with a new entry. If the JSON file does not exist, a new one is created. The data is formatted in a structured manner with timestamps as keys.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/melvonaut/mel_telemetry.py</code> <pre><code>async def store_observation_json(self) -&gt; None:\n    \"\"\"\n    Stores the telemetry observation data in a JSON file.\n\n    This function retrieves the existing telemetry data from the JSON file\n    and updates it with a new entry. If the JSON file does not exist, a new\n    one is created. The data is formatted in a structured manner with timestamps\n    as keys.\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    logger.debug(\"Storing observation as json.\")\n    try:\n        async with async_open(con.TELEMETRY_LOCATION_JSON, \"r\") as afp:\n            raw_telemetry = await afp.read()\n            dict_telemetry = json.loads(raw_telemetry)\n    except FileNotFoundError:\n        logger.debug(f\"{con.TELEMETRY_LOCATION_JSON} does not exist.\")\n        dict_telemetry = {}\n\n    if self.timestamp:\n        timestamp = self.timestamp.isoformat()\n    else:\n        timestamp = datetime.datetime.now().isoformat()\n    new_telemetry_entry = self.model_dump(exclude={\"timestamp\"})\n    dict_telemetry[timestamp] = new_telemetry_entry\n    json_telemetry = json.dumps(dict_telemetry, indent=4, sort_keys=True)\n\n    async with async_open(con.TELEMETRY_LOCATION_JSON, \"w\") as afp:\n        # logger.debug(f\"Writing to {con.TELEMETRY_LOCATION_JSON}\")\n        await afp.write(str(json_telemetry))\n    logger.debug(\"Observation stored\")\n</code></pre>"},{"location":"melvonaut/#melvonaut.settings","title":"<code>settings</code>","text":""},{"location":"melvonaut/#melvonaut.settings.file_log_handler_id","title":"<code>file_log_handler_id = None</code>  <code>module-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.settings.settings","title":"<code>settings = Settings()</code>  <code>module-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.settings.Settings","title":"<code>Settings</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Startup settings for Melvonaut, can be changed by Melvonaut API.</p> Source code in <code>src/melvonaut/settings.py</code> <pre><code>class Settings(BaseModel):\n    \"\"\"Startup settings for Melvonaut, can be changed by Melvonaut API.\"\"\"\n\n    model_config = {\"arbitrary_types_allowed\": True}\n\n    # [Logging]\n    TRACING: bool = bool(os.getenv(\"TRACING\", False))\n\n    TERMINAL_LOGGING_LEVEL: str = os.getenv(\"TERMINAL_LOGGING_LEVEL\", \"INFO\").upper()\n    FILE_LOGGING_LEVEL: str = os.getenv(\"FILE_LOGGING_LEVEL\", \"INFO\").upper()\n\n    API_PORT: int = int(os.getenv(\"API_PORT\", 8080))\n    DISCORD_WEBHOOK_TOKEN: Optional[str] = os.getenv(\"DISCORD_WEBHOOK_TOKEN\", None)\n    DISCORD_ALERTS_ENABLED: bool = bool(os.getenv(\"DISCORD_ALERTS_ENABLED\", False))\n\n    NETWORK_SIM_ENABLED: bool = bool(os.getenv(\"NETWORK_SIMULATION\", False))\n\n    ## [Stateplaning]\n    OBSERVATION_REFRESH_RATE: int = int(\n        os.getenv(\"OBSERVATION_REFRESH_RATE\", 5)\n    )  # Seconds between observation requests\n    BATTERY_LOW_THRESHOLD: int = int(os.getenv(\"BATTERY_LOW_THRESHOLD\", 20))\n    BATTERY_HIGH_THRESHOLD: int = int(\n        os.getenv(\"BATTERY_HIGH_THRESHOLD\", 0)\n    )  # Difference to Max Battery before switching\n\n    TARGET_ANGLE_DEG: float = float(\n        os.getenv(\"TARGET_ANGLE_DEG\", 23.0)\n    )  # The angle was calculated through simulations\n    # With total speed over 50, cannot use wide angle camera\n    # 49.9 = y + x\n    # x = 2.35585 * y\n    # 49.9 = 2.35585 * y + y\n    # 49.9 = 3.35585 * y\n    # y = 49.9 / 3.35585\n    # y = 14.87\n    # 49.9 - 14.87 = 35.03 = x\n    TARGET_SPEED_NORMAL_X: float = float(\n        os.getenv(\"TARGET_SPEED_NORMAL_X\", 35.03)\n    )  # 2.35585 times as much as Y\n    TARGET_SPEED_NORMAL_Y: float = float(os.getenv(\"TARGET_SPEED_NORMAL_Y\", 14.87))\n\n    # With total speed over 10, cannot use narrow angle camera\n    # 9.9 = y + x\n    # y = 9.9 / 3.35585\n    # y = 2.95\n    # 9.9 - 2.95 = 6.95 = x\n    TARGET_SPEED_NARROW_X: float = float(os.getenv(\"TARGET_SPEED_NARROW_X\", 6.95))\n    TARGET_SPEED_NARROW_Y: float = float(os.getenv(\"TARGET_SPEED_NARROW_Y\", 2.95))\n\n    # Total speed can be up to 71\n    # 71 = y + x\n    # y = 71 / 3.35585\n    # y = 21.16\n    # 71 - 21.16 = 49.84 = x\n    TARGET_SPEED_WIDE_X: float = float(os.getenv(\"TARGET_SPEED_WIDE_X\", 49.84))\n    TARGET_SPEED_WIDE_Y: float = float(os.getenv(\"TARGET_SPEED_WIDE_Y\", 21.16))\n\n    DISTANCE_BETWEEN_IMAGES: int = int(\n        os.getenv(\"DISTANCE_BETWEEN_IMAGES\", 450)\n    )  # How many pixel before taking another image\n\n    # [Melvin Task Planing]\n    # Standard mapping, with no objectives and the camera angle below\n    CURRENT_MELVIN_TASK: MELVINTask = MELVINTask.Mapping\n    TARGET_CAMERA_ANGLE_ACQUISITION: CameraAngle = CameraAngle.Narrow\n\n    # Automatically do the next upcoming objective\n    # CURRENT_MELVIN_TASK: MELVINTasks = MELVINTasks.Next_objective\n\n    # Do a specific objective\n    # CURRENT_MELVIN_TASK: MELVINTasks = MELVINTasks.Fixed_objective\n    # FIXED_OBJECTIVE = \"Aurora 10\"\n\n    # Go for the emergency beacon tracker\n    # CURRENT_MELVIN_TASK: MELVINTask = MELVINTask.EBT\n\n    # [Legacy]\n    # To set a custom time window to be active, or to disable all timing checks\n    DO_TIMING_CHECK: bool = False\n    START_TIME: datetime.datetime = datetime.datetime(\n        2025, 1, 2, 12, 00, tzinfo=datetime.timezone.utc\n    )\n    STOP_TIME: datetime.datetime = datetime.datetime(\n        2025, 1, 30, 12, 00, tzinfo=datetime.timezone.utc\n    )\n    DO_ACTUALLY_EXIT: bool = True  # Used in testing\n    OVERRIDES: dict[str, Any] = {}\n\n    # load settings\n    def load_settings(self) -&gt; None:\n        \"\"\"Loads settings from a persistent JSON file.\n\n        If the settings file does not exist or contains invalid JSON,\n        the overrides dictionary is reset to an empty state.\n        \"\"\"\n        if not pathlib.Path(con.MEL_PERSISTENT_SETTINGS).exists():\n            logger.debug(\"Settings don't exist\")\n            self.OVERRIDES = {}\n        with open(con.MEL_PERSISTENT_SETTINGS, \"r\") as f:\n            try:\n                loaded = json.loads(f.read())\n            except JSONDecodeError:\n                logger.warning(\"Failed to load settings\")\n                self.OVERRIDES = {}\n                return\n            # logger.debug(f\"{loaded=}\")\n            for key, value in loaded.items():\n                self.OVERRIDES[key.upper()] = value\n            # logger.debug(f\"{self.OVERRIDES=}\")\n\n    # save settings\n    def save_settings(self) -&gt; None:\n        \"\"\"Saves the current settings overrides to a persistent JSON file.\"\"\"\n        with open(con.MEL_PERSISTENT_SETTINGS, \"w\") as f:\n            f.write(json.dumps(self.OVERRIDES))\n\n    # get settings\n    def get_setting(self, key: str, default: Any = None) -&gt; Any:\n        \"\"\"Retrieves a setting value from overrides or returns the default.\n\n        Args:\n            key (str): The setting key to retrieve.\n            default (Any, optional): The default value if the key is not found. Defaults to None.\n\n        Returns:\n            Any: The value of the setting if it exists, otherwise the default.\n        \"\"\"\n        return self.OVERRIDES.get(key.upper(), default)\n\n    # set setting\n    def set_setting(self, key: str, value: Any) -&gt; None:\n        \"\"\"Sets a single setting in overrides and saves the settings.\n\n        Args:\n            key (str): The setting key.\n            value (Any): The value to assign to the setting.\n        \"\"\"\n        # logger.debug(f\"Setting {key.upper()} to {value}\")\n        # logger.debug(f\"{self.OVERRIDES=}\")\n        self.OVERRIDES[key.upper()] = value\n        # logger.debug(f\"{self.OVERRIDES=}\")\n        self.save_settings()\n\n    def set_settings(self, key_values: dict[str, Any]) -&gt; None:\n        \"\"\"Sets multiple settings at once and saves them.\n\n        Args:\n            key_values (dict[str, Any]): A dictionary of key-value pairs to update.\n        \"\"\"\n        # logger.debug(f\"Setting {self.OVERRIDES}\")\n        if len(key_values.keys()) == 0:\n            logger.debug(\"Clearing settings\")\n            self.set_setting(\"OVERRIDES\", {})\n        else:\n            for key, value in key_values.items():\n                self.set_setting(key, value)\n        # logger.debug(f\"Setting {self.OVERRIDES}\")\n        self.save_settings()\n\n    def delete_settings(self, keys: list[str]) -&gt; None:\n        \"\"\"Deletes specified settings from overrides and saves the settings.\n\n        Args:\n            keys (list[str]): A list of setting keys to remove.\n        \"\"\"\n        # logger.debug(f\"Deleting {keys}\")\n        for key in keys:\n            del self.OVERRIDES[key.upper()]\n        # logger.debug(f\"{self.OVERRIDES=}\")\n        self.save_settings()\n\n    def init_settings(self) -&gt; bool:\n        \"\"\"Initializes settings by checking for an existing settings file.\n\n        Returns:\n            bool: True if settings were newly created, False if they already exist.\n        \"\"\"\n        if pathlib.Path(con.MEL_PERSISTENT_SETTINGS).exists():\n            logger.debug(\"Settings already exist\")\n            return False\n        logger.debug(\"Settings created\")\n        self.save_settings()\n        return True\n\n    # clear settings\n    def clear_settings(self) -&gt; None:\n        \"\"\"Clears all settings by setting overrides to None and saving.\"\"\"\n        self.OVERRIDES = None  # type: ignore\n        # logger.debug(f\"{self.OVERRIDES=}\")\n\n    def get_default_setting(self, key: str) -&gt; Any:\n        \"\"\"Retrieves the default value of a setting from the class attributes.\n\n        Args:\n            key (str): The setting key to retrieve.\n\n        Returns:\n            Any: The default value of the setting.\n        \"\"\"\n        return super().__getattribute__(key)\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initializes the Settings object, loading settings if they exist.\"\"\"\n        super().__init__()\n        if not self.init_settings():\n            self.load_settings()\n\n    def __getattribute__(self, item: str) -&gt; Any:\n        \"\"\"Overrides attribute access to check overrides before default settings.\n\n        Args:\n            item (str): The attribute key to retrieve.\n\n        Returns:\n            Any: The overridden value if it exists, otherwise the default.\n        \"\"\"\n        if item.startswith(\"__\"):\n            return super().__getattribute__(item)\n        # logger.debug(f\"Getting {item}\")\n        overrides = super().__getattribute__(\"OVERRIDES\")\n        if item.upper() in overrides:\n            return overrides[item.upper()]\n        return super().__getattribute__(item)\n\n    def __setattr__(self, key: str, value: Any) -&gt; None:\n        \"\"\"Overrides attribute setting to ensure settings are properly stored.\n\n        Args:\n            key (str): The setting key.\n            value (Any): The value to assign to the setting.\n        \"\"\"\n        # logger.debug(f\"Setting {key} to {value}\")\n        if key == \"OVERRIDES\" and value is None:\n            self.OVERRIDES.clear()\n            self.save_settings()\n        elif type(value) is dict:\n            self.set_settings(value)\n        else:\n            self.set_setting(key.upper(), value)\n</code></pre>"},{"location":"melvonaut/#melvonaut.settings.Settings.API_PORT","title":"<code>API_PORT = int(os.getenv('API_PORT', 8080))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.settings.Settings.BATTERY_HIGH_THRESHOLD","title":"<code>BATTERY_HIGH_THRESHOLD = int(os.getenv('BATTERY_HIGH_THRESHOLD', 0))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.settings.Settings.BATTERY_LOW_THRESHOLD","title":"<code>BATTERY_LOW_THRESHOLD = int(os.getenv('BATTERY_LOW_THRESHOLD', 20))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.settings.Settings.CURRENT_MELVIN_TASK","title":"<code>CURRENT_MELVIN_TASK = MELVINTask.Mapping</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.settings.Settings.DISCORD_ALERTS_ENABLED","title":"<code>DISCORD_ALERTS_ENABLED = bool(os.getenv('DISCORD_ALERTS_ENABLED', False))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.settings.Settings.DISCORD_WEBHOOK_TOKEN","title":"<code>DISCORD_WEBHOOK_TOKEN = os.getenv('DISCORD_WEBHOOK_TOKEN', None)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.settings.Settings.DISTANCE_BETWEEN_IMAGES","title":"<code>DISTANCE_BETWEEN_IMAGES = int(os.getenv('DISTANCE_BETWEEN_IMAGES', 450))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.settings.Settings.DO_ACTUALLY_EXIT","title":"<code>DO_ACTUALLY_EXIT = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.settings.Settings.DO_TIMING_CHECK","title":"<code>DO_TIMING_CHECK = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.settings.Settings.FILE_LOGGING_LEVEL","title":"<code>FILE_LOGGING_LEVEL = os.getenv('FILE_LOGGING_LEVEL', 'INFO').upper()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.settings.Settings.NETWORK_SIM_ENABLED","title":"<code>NETWORK_SIM_ENABLED = bool(os.getenv('NETWORK_SIMULATION', False))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.settings.Settings.OBSERVATION_REFRESH_RATE","title":"<code>OBSERVATION_REFRESH_RATE = int(os.getenv('OBSERVATION_REFRESH_RATE', 5))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.settings.Settings.OVERRIDES","title":"<code>OVERRIDES = {}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.settings.Settings.START_TIME","title":"<code>START_TIME = datetime.datetime(2025, 1, 2, 12, 0, tzinfo=datetime.timezone.utc)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.settings.Settings.STOP_TIME","title":"<code>STOP_TIME = datetime.datetime(2025, 1, 30, 12, 0, tzinfo=datetime.timezone.utc)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.settings.Settings.TARGET_ANGLE_DEG","title":"<code>TARGET_ANGLE_DEG = float(os.getenv('TARGET_ANGLE_DEG', 23.0))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.settings.Settings.TARGET_CAMERA_ANGLE_ACQUISITION","title":"<code>TARGET_CAMERA_ANGLE_ACQUISITION = CameraAngle.Narrow</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.settings.Settings.TARGET_SPEED_NARROW_X","title":"<code>TARGET_SPEED_NARROW_X = float(os.getenv('TARGET_SPEED_NARROW_X', 6.95))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.settings.Settings.TARGET_SPEED_NARROW_Y","title":"<code>TARGET_SPEED_NARROW_Y = float(os.getenv('TARGET_SPEED_NARROW_Y', 2.95))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.settings.Settings.TARGET_SPEED_NORMAL_X","title":"<code>TARGET_SPEED_NORMAL_X = float(os.getenv('TARGET_SPEED_NORMAL_X', 35.03))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.settings.Settings.TARGET_SPEED_NORMAL_Y","title":"<code>TARGET_SPEED_NORMAL_Y = float(os.getenv('TARGET_SPEED_NORMAL_Y', 14.87))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.settings.Settings.TARGET_SPEED_WIDE_X","title":"<code>TARGET_SPEED_WIDE_X = float(os.getenv('TARGET_SPEED_WIDE_X', 49.84))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.settings.Settings.TARGET_SPEED_WIDE_Y","title":"<code>TARGET_SPEED_WIDE_Y = float(os.getenv('TARGET_SPEED_WIDE_Y', 21.16))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.settings.Settings.TERMINAL_LOGGING_LEVEL","title":"<code>TERMINAL_LOGGING_LEVEL = os.getenv('TERMINAL_LOGGING_LEVEL', 'INFO').upper()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.settings.Settings.TRACING","title":"<code>TRACING = bool(os.getenv('TRACING', False))</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.settings.Settings.model_config","title":"<code>model_config = {'arbitrary_types_allowed': True}</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.settings.Settings.__getattribute__","title":"<code>__getattribute__(item)</code>","text":"<p>Overrides attribute access to check overrides before default settings.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>The attribute key to retrieve.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The overridden value if it exists, otherwise the default.</p> Source code in <code>src/melvonaut/settings.py</code> <pre><code>def __getattribute__(self, item: str) -&gt; Any:\n    \"\"\"Overrides attribute access to check overrides before default settings.\n\n    Args:\n        item (str): The attribute key to retrieve.\n\n    Returns:\n        Any: The overridden value if it exists, otherwise the default.\n    \"\"\"\n    if item.startswith(\"__\"):\n        return super().__getattribute__(item)\n    # logger.debug(f\"Getting {item}\")\n    overrides = super().__getattribute__(\"OVERRIDES\")\n    if item.upper() in overrides:\n        return overrides[item.upper()]\n    return super().__getattribute__(item)\n</code></pre>"},{"location":"melvonaut/#melvonaut.settings.Settings.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the Settings object, loading settings if they exist.</p> Source code in <code>src/melvonaut/settings.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initializes the Settings object, loading settings if they exist.\"\"\"\n    super().__init__()\n    if not self.init_settings():\n        self.load_settings()\n</code></pre>"},{"location":"melvonaut/#melvonaut.settings.Settings.__setattr__","title":"<code>__setattr__(key, value)</code>","text":"<p>Overrides attribute setting to ensure settings are properly stored.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The setting key.</p> required <code>value</code> <code>Any</code> <p>The value to assign to the setting.</p> required Source code in <code>src/melvonaut/settings.py</code> <pre><code>def __setattr__(self, key: str, value: Any) -&gt; None:\n    \"\"\"Overrides attribute setting to ensure settings are properly stored.\n\n    Args:\n        key (str): The setting key.\n        value (Any): The value to assign to the setting.\n    \"\"\"\n    # logger.debug(f\"Setting {key} to {value}\")\n    if key == \"OVERRIDES\" and value is None:\n        self.OVERRIDES.clear()\n        self.save_settings()\n    elif type(value) is dict:\n        self.set_settings(value)\n    else:\n        self.set_setting(key.upper(), value)\n</code></pre>"},{"location":"melvonaut/#melvonaut.settings.Settings.clear_settings","title":"<code>clear_settings()</code>","text":"<p>Clears all settings by setting overrides to None and saving.</p> Source code in <code>src/melvonaut/settings.py</code> <pre><code>def clear_settings(self) -&gt; None:\n    \"\"\"Clears all settings by setting overrides to None and saving.\"\"\"\n    self.OVERRIDES = None  # type: ignore\n</code></pre>"},{"location":"melvonaut/#melvonaut.settings.Settings.delete_settings","title":"<code>delete_settings(keys)</code>","text":"<p>Deletes specified settings from overrides and saves the settings.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>list[str]</code> <p>A list of setting keys to remove.</p> required Source code in <code>src/melvonaut/settings.py</code> <pre><code>def delete_settings(self, keys: list[str]) -&gt; None:\n    \"\"\"Deletes specified settings from overrides and saves the settings.\n\n    Args:\n        keys (list[str]): A list of setting keys to remove.\n    \"\"\"\n    # logger.debug(f\"Deleting {keys}\")\n    for key in keys:\n        del self.OVERRIDES[key.upper()]\n    # logger.debug(f\"{self.OVERRIDES=}\")\n    self.save_settings()\n</code></pre>"},{"location":"melvonaut/#melvonaut.settings.Settings.get_default_setting","title":"<code>get_default_setting(key)</code>","text":"<p>Retrieves the default value of a setting from the class attributes.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The setting key to retrieve.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The default value of the setting.</p> Source code in <code>src/melvonaut/settings.py</code> <pre><code>def get_default_setting(self, key: str) -&gt; Any:\n    \"\"\"Retrieves the default value of a setting from the class attributes.\n\n    Args:\n        key (str): The setting key to retrieve.\n\n    Returns:\n        Any: The default value of the setting.\n    \"\"\"\n    return super().__getattribute__(key)\n</code></pre>"},{"location":"melvonaut/#melvonaut.settings.Settings.get_setting","title":"<code>get_setting(key, default=None)</code>","text":"<p>Retrieves a setting value from overrides or returns the default.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The setting key to retrieve.</p> required <code>default</code> <code>Any</code> <p>The default value if the key is not found. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>The value of the setting if it exists, otherwise the default.</p> Source code in <code>src/melvonaut/settings.py</code> <pre><code>def get_setting(self, key: str, default: Any = None) -&gt; Any:\n    \"\"\"Retrieves a setting value from overrides or returns the default.\n\n    Args:\n        key (str): The setting key to retrieve.\n        default (Any, optional): The default value if the key is not found. Defaults to None.\n\n    Returns:\n        Any: The value of the setting if it exists, otherwise the default.\n    \"\"\"\n    return self.OVERRIDES.get(key.upper(), default)\n</code></pre>"},{"location":"melvonaut/#melvonaut.settings.Settings.init_settings","title":"<code>init_settings()</code>","text":"<p>Initializes settings by checking for an existing settings file.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if settings were newly created, False if they already exist.</p> Source code in <code>src/melvonaut/settings.py</code> <pre><code>def init_settings(self) -&gt; bool:\n    \"\"\"Initializes settings by checking for an existing settings file.\n\n    Returns:\n        bool: True if settings were newly created, False if they already exist.\n    \"\"\"\n    if pathlib.Path(con.MEL_PERSISTENT_SETTINGS).exists():\n        logger.debug(\"Settings already exist\")\n        return False\n    logger.debug(\"Settings created\")\n    self.save_settings()\n    return True\n</code></pre>"},{"location":"melvonaut/#melvonaut.settings.Settings.load_settings","title":"<code>load_settings()</code>","text":"<p>Loads settings from a persistent JSON file.</p> <p>If the settings file does not exist or contains invalid JSON, the overrides dictionary is reset to an empty state.</p> Source code in <code>src/melvonaut/settings.py</code> <pre><code>def load_settings(self) -&gt; None:\n    \"\"\"Loads settings from a persistent JSON file.\n\n    If the settings file does not exist or contains invalid JSON,\n    the overrides dictionary is reset to an empty state.\n    \"\"\"\n    if not pathlib.Path(con.MEL_PERSISTENT_SETTINGS).exists():\n        logger.debug(\"Settings don't exist\")\n        self.OVERRIDES = {}\n    with open(con.MEL_PERSISTENT_SETTINGS, \"r\") as f:\n        try:\n            loaded = json.loads(f.read())\n        except JSONDecodeError:\n            logger.warning(\"Failed to load settings\")\n            self.OVERRIDES = {}\n            return\n        # logger.debug(f\"{loaded=}\")\n        for key, value in loaded.items():\n            self.OVERRIDES[key.upper()] = value\n</code></pre>"},{"location":"melvonaut/#melvonaut.settings.Settings.save_settings","title":"<code>save_settings()</code>","text":"<p>Saves the current settings overrides to a persistent JSON file.</p> Source code in <code>src/melvonaut/settings.py</code> <pre><code>def save_settings(self) -&gt; None:\n    \"\"\"Saves the current settings overrides to a persistent JSON file.\"\"\"\n    with open(con.MEL_PERSISTENT_SETTINGS, \"w\") as f:\n        f.write(json.dumps(self.OVERRIDES))\n</code></pre>"},{"location":"melvonaut/#melvonaut.settings.Settings.set_setting","title":"<code>set_setting(key, value)</code>","text":"<p>Sets a single setting in overrides and saves the settings.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The setting key.</p> required <code>value</code> <code>Any</code> <p>The value to assign to the setting.</p> required Source code in <code>src/melvonaut/settings.py</code> <pre><code>def set_setting(self, key: str, value: Any) -&gt; None:\n    \"\"\"Sets a single setting in overrides and saves the settings.\n\n    Args:\n        key (str): The setting key.\n        value (Any): The value to assign to the setting.\n    \"\"\"\n    # logger.debug(f\"Setting {key.upper()} to {value}\")\n    # logger.debug(f\"{self.OVERRIDES=}\")\n    self.OVERRIDES[key.upper()] = value\n    # logger.debug(f\"{self.OVERRIDES=}\")\n    self.save_settings()\n</code></pre>"},{"location":"melvonaut/#melvonaut.settings.Settings.set_settings","title":"<code>set_settings(key_values)</code>","text":"<p>Sets multiple settings at once and saves them.</p> <p>Parameters:</p> Name Type Description Default <code>key_values</code> <code>dict[str, Any]</code> <p>A dictionary of key-value pairs to update.</p> required Source code in <code>src/melvonaut/settings.py</code> <pre><code>def set_settings(self, key_values: dict[str, Any]) -&gt; None:\n    \"\"\"Sets multiple settings at once and saves them.\n\n    Args:\n        key_values (dict[str, Any]): A dictionary of key-value pairs to update.\n    \"\"\"\n    # logger.debug(f\"Setting {self.OVERRIDES}\")\n    if len(key_values.keys()) == 0:\n        logger.debug(\"Clearing settings\")\n        self.set_setting(\"OVERRIDES\", {})\n    else:\n        for key, value in key_values.items():\n            self.set_setting(key, value)\n    # logger.debug(f\"Setting {self.OVERRIDES}\")\n    self.save_settings()\n</code></pre>"},{"location":"melvonaut/#melvonaut.state_planer","title":"<code>state_planer</code>","text":""},{"location":"melvonaut/#melvonaut.state_planer.state_planner","title":"<code>state_planner = StatePlanner()</code>  <code>module-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.state_planer.StatePlanner","title":"<code>StatePlanner</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/melvonaut/state_planer.py</code> <pre><code>class StatePlanner(BaseModel):\n    melv_id: int = random.randint(0, 9999)\n    current_telemetry: Optional[MelTelemetry] = None\n    previous_telemetry: Optional[MelTelemetry] = None\n\n    previous_state: Optional[State] = None\n    state_change_time: datetime.datetime = datetime.datetime.now()\n\n    submitted_transition_request: bool = False\n\n    target_state: Optional[State] = None\n\n    _accelerating: bool = False\n\n    _run_get_image_task: Optional[asyncio.Task[None]] = None\n\n    _aiohttp_session: Optional[aiohttp.ClientSession] = None\n\n    _target_vel_x: Optional[float] = None\n    _target_vel_y: Optional[float] = None\n\n    _z_obj_list: list[ZonedObjective] = []\n\n    recent_events: list[Event] = []\n\n    _current_obj_name: str = \"\"\n\n    def model_post_init(self, __context__: Any) -&gt; None:\n        \"\"\"Initializes the recent_events list by loading events from a CSV file.\n\n        Args:\n            __context__ (Any): Context data passed during initialization.\n        \"\"\"\n        self.recent_events = Event.load_events_from_csv(path=con.EVENT_LOCATION_CSV)\n\n    def get_current_state(self) -&gt; State:\n        \"\"\"Retrieves the current state from telemetry data.\n\n        Returns:\n            State: The current state if telemetry is available, otherwise State.Unknown.\n        \"\"\"\n        if self.current_telemetry is None:\n            return State.Unknown\n        return self.current_telemetry.state\n\n    def get_previous_state(self) -&gt; State:\n        \"\"\"Retrieves the previous state from telemetry data.\n\n        Returns:\n            State: The previous state if telemetry is available, otherwise State.Unknown.\n        \"\"\"\n        if self.previous_telemetry is None:\n            return State.Unknown\n        return self.previous_telemetry.state\n\n    def get_simulation_speed(self) -&gt; int:\n        \"\"\"Gets the current simulation speed from telemetry data.\n\n        Returns:\n            int: The simulation speed if telemetry is available, otherwise 1.\n        \"\"\"\n        if self.current_telemetry is None:\n            return 1\n        return self.current_telemetry.simulation_speed\n\n    def get_time_since_state_change(self) -&gt; datetime.timedelta:\n        \"\"\"Calculates the time elapsed since the last state change.\n\n        Returns:\n            datetime.timedelta: The time difference between now and the last state change.\n        \"\"\"\n        return datetime.datetime.now() - self.state_change_time\n\n    def calc_transition_remaining_time(self) -&gt; datetime.timedelta:\n        \"\"\"Calculates the remaining time for state transition.\n\n        Returns:\n            datetime.timedelta: The remaining transition time based on the simulation speed.\n        \"\"\"\n        if self.get_current_state() is State.Transition:\n            logger.debug(\"Not in transition state, returning 0\")\n            return datetime.timedelta(0)\n        elif self.previous_state == State.Safe:\n            total_time = datetime.timedelta(\n                seconds=con.STATE_TRANSITION_FROM_SAFE_TIME\n                / self.get_simulation_speed()\n            )\n            return total_time - self.get_time_since_state_change()\n        else:\n            total_time = datetime.timedelta(\n                seconds=con.STATE_TRANSITION_TIME / self.get_simulation_speed()\n            )\n            return total_time - self.get_time_since_state_change()\n\n    def calc_current_location(self) -&gt; tuple[float, float]:\n        \"\"\"Estimates the current location based on telemetry data and time elapsed.\n\n        Returns:\n            tuple[float, float]: The estimated (x, y) coordinates.\n        \"\"\"\n        if self.current_telemetry is None:\n            return 0.0, 0.0\n        time_since_observation = (\n            live_utc() - self.current_telemetry.timestamp\n        ).total_seconds()\n        current_x = (\n            self.current_telemetry.width_x\n            + self.current_telemetry.vx * time_since_observation\n        )\n        current_y = (\n            self.current_telemetry.height_y\n            + self.current_telemetry.vy * time_since_observation\n        )\n        return current_x, current_y\n\n    async def trigger_velocity_change(self, new_vel_x: float, new_vel_y: float) -&gt; None:\n        \"\"\"Sets new values for accelartion, also set _accelerating\n\n        Args:\n            new_vel_x (float): The target velocity in the x direction.\n            new_vel_y (float): The target velocity in the y direction.\n        \"\"\"\n\n        self._target_vel_x = new_vel_x\n        self._target_vel_y = new_vel_y\n\n        if self.current_telemetry is None:\n            logger.warning(\"No telemetry data available. Cannot set velocity.\")\n            return\n        if (\n            new_vel_x == self.current_telemetry.vx\n            and new_vel_y == self.current_telemetry.vy\n        ):\n            self._accelerating = False\n            logger.info(\"Target velocity already set. Not changing velocity.\")\n            return\n        request_body = {\n            \"vel_x\": new_vel_x,\n            \"vel_y\": new_vel_y,\n            \"camera_angle\": self.current_telemetry.angle,\n            \"state\": self.get_current_state(),\n        }\n        async with aiohttp.ClientSession() as session:\n            async with session.put(con.CONTROL_ENDPOINT, json=request_body) as response:\n                if response.status == 200:\n                    self._accelerating = True\n                    logger.info(f\"Velocity set to {new_vel_x}, {new_vel_y}\")\n                else:\n                    logger.error(f\"Failed to set velocity to {new_vel_x}, {new_vel_y}\")\n\n    async def trigger_camera_angle_change(self, new_angle: CameraAngle) -&gt; None:\n        \"\"\"Tries to change the camera angle to new_angle\n\n        Args:\n            new_angle (CameraAngle): The desired camera angle.\n        \"\"\"\n        if self.current_telemetry is None:\n            logger.warning(\"No telemetry data available. Cannot set camera angle.\")\n            return\n        if new_angle == self.current_telemetry.angle:\n            logger.info(\"Target camera angle already set. Not changing angle.\")\n            return\n        request_body = {\n            \"vel_x\": self.current_telemetry.vx,\n            \"vel_y\": self.current_telemetry.vy,\n            \"camera_angle\": new_angle,\n            \"state\": self.get_current_state(),\n        }\n        async with aiohttp.ClientSession() as session:\n            async with session.put(con.CONTROL_ENDPOINT, json=request_body) as response:\n                if response.status == 200:\n                    self.current_telemetry.angle = new_angle\n                    logger.info(f\"Camera angle set to {new_angle}\")\n                else:\n                    logger.error(f\"Failed to set camera angle to {new_angle}\")\n\n    async def trigger_state_transition(self, new_state: State) -&gt; None:\n        \"\"\"Initiates a state transition if valid conditions are met.\n\n        Args:\n            new_state (State): The target state to transition to.\n        \"\"\"\n        if new_state in [State.Transition, State.Unknown, State.Deployment, State.Safe]:\n            logger.warning(f\"Cannot transition to {new_state}.\")\n            return\n        if self.current_telemetry is None:\n            logger.warning(\"No telemetry data available. Cannot initiate transition.\")\n            return\n        if self.current_telemetry.state == State.Transition:\n            logger.debug(\"Already in transition state, not starting transition.\")\n            return\n        if new_state == self.get_current_state():\n            logger.debug(f\"State is already {new_state}, not starting transition.\")\n            return\n        request_body = {\n            \"state\": new_state,\n            \"vel_x\": self.current_telemetry.vx,\n            \"vel_y\": self.current_telemetry.vy,\n            \"camera_angle\": self.current_telemetry.angle,\n        }\n        async with aiohttp.ClientSession() as session:\n            async with session.put(con.CONTROL_ENDPOINT, json=request_body) as response:\n                if response.status == 200:\n                    logger.info(\n                        f\"Started transition to {new_state} at battery level {self.current_telemetry.battery}\"\n                    )\n                    self.submitted_transition_request = True\n                    self.target_state = new_state\n                else:\n                    logger.warning(\n                        f\"Failed to transition to {new_state}: {response.status}\"\n                    )\n                    logger.debug(f\"Response body: {await response.text()}\")\n\n    async def switch_if_battery_low(\n        self, state_low_battery: State, state_high_battery: State\n    ) -&gt; None:\n        \"\"\"Switches state based on battery level.\n\n        Args:\n            state_low_battery (State): The state to switch to when battery is low.\n            state_high_battery (State): The state to switch to when battery is sufficient.\n        \"\"\"\n        if self.current_telemetry is None:\n            logger.warning(\n                \"No telemetry data available. Cannot plan battery based switching.\"\n            )\n            return\n        if self.current_telemetry.battery &lt;= settings.BATTERY_LOW_THRESHOLD:\n            if self.get_current_state() == state_low_battery:\n                return\n            logger.debug(\n                f\"State is {self.get_current_state()}, Battery is low, triggering transition to {state_low_battery}\"\n            )\n            await self.trigger_state_transition(state_low_battery)\n        else:\n            if self.get_current_state() == state_high_battery:\n                return\n            logger.debug(\n                f\"State is {self.get_current_state()}, Battery is high, triggering transition to {state_high_battery}\"\n            )\n            await self.trigger_state_transition(state_high_battery)\n\n    async def plan_state_switching(self) -&gt; None:\n        \"\"\"Plans and executes state transitions based on current telemetry data.\n\n        This function checks the current state and decides whether to transition\n        to another state based on conditions like battery level and velocity.\n\n        Logs relevant debug information and triggers state transitions when necessary.\n\n        Returns:\n            None\n        \"\"\"\n        if self.current_telemetry is None:\n            logger.warning(\"No telemetry data available. Cannot plan state switching.\")\n            return\n\n        state = self.get_current_state()\n\n        match state:\n            case State.Transition:\n                logger.debug(\n                    f\"Time since state change: {self.get_time_since_state_change()}\"\n                )\n                expected_time_to_complete = self.calc_transition_remaining_time()\n                limited_log(\n                    f\"State is Transition to {self.target_state}, waiting for transition to complete.\\nExpected time to complete state transition: {expected_time_to_complete}\"\n                )\n                # logger.debug(\n                #     f\"Previous state: {self.get_previous_state()}, Current state: {self.get_current_state()}\"\n                # )\n            case State.Acquisition:\n                # in EBT leave once everything is set\n                if settings.CURRENT_MELVIN_TASK == MELVINTask.EBT:\n                    if (\n                        self._target_vel_x\n                        and self._target_vel_y\n                        and self.current_telemetry.angle\n                        == settings.TARGET_CAMERA_ANGLE_ACQUISITION\n                        and self._target_vel_x == self.current_telemetry.vx\n                        and self._target_vel_y == self.current_telemetry.vy\n                    ):\n                        await self.trigger_state_transition(State.Communication)\n\n                await self.switch_if_battery_low(State.Charge, State.Acquisition)\n\n            case State.Charge:\n                if (\n                    self.current_telemetry.battery\n                    &gt;= self.current_telemetry.max_battery\n                    - settings.BATTERY_HIGH_THRESHOLD\n                ):\n                    if settings.CURRENT_MELVIN_TASK == MELVINTask.EBT:\n                        # starting ebt, but speed/angle not set yet\n\n                        logger.info(\n                            f\"EBT Task, Angle: telemetry: {self.current_telemetry.angle} vs target: {settings.TARGET_CAMERA_ANGLE_ACQUISITION}\"\n                        )\n                        logger.info(\n                            f\"EBT Task, vx: {self.current_telemetry.vx} vs target: {self._target_vel_x}\"\n                        )\n                        logger.info(\n                            f\"EBT Task, vy: {self.current_telemetry.vy} vs target: {self._target_vel_y}\"\n                        )\n                        if (\n                            self._target_vel_x is None\n                            or self._target_vel_y is None\n                            or self.current_telemetry.angle\n                            != settings.TARGET_CAMERA_ANGLE_ACQUISITION\n                            or self._target_vel_x != self.current_telemetry.vx\n                            or self._target_vel_y != self.current_telemetry.vy\n                        ):\n                            await self.trigger_state_transition(State.Acquisition)\n                        else:\n                            # logger.info(\"starting comms!\")\n                            await self.trigger_state_transition(State.Communication)\n\n                    else:\n                        # logger.info(\"starting acq!\")\n                        await self.trigger_state_transition(State.Acquisition)\n\n            case State.Safe:\n                if self.current_telemetry.battery &gt;= (\n                    self.current_telemetry.max_battery * 0.5\n                ):\n                    await self.trigger_state_transition(State.Acquisition)\n                else:\n                    await self.trigger_state_transition(State.Charge)\n                await self.switch_if_battery_low(State.Charge, State.Acquisition)\n            case State.Communication:\n                await self.switch_if_battery_low(State.Charge, State.Communication)\n            case State.Deployment:\n                logger.debug(\n                    \"State is Deployment, triggering transition to Acquisition\"\n                )\n                await self.trigger_state_transition(State.Acquisition)\n\n    async def update_telemetry(self, new_telemetry: MelTelemetry) -&gt; None:\n        \"\"\"Updates the telemetry data and handles state changes.\n\n        This function updates the previous and current telemetry readings,\n        logs relevant debug information, and checks for state changes.\n\n        If a state change occurs, it logs the transition, cancels image\n        retrieval tasks if necessary, and triggers appropriate actions based on\n        the new state.\n\n        Args:\n            new_telemetry (MelTelemetry): The new telemetry data to update.\n\n        Returns:\n            None\n        \"\"\"\n        self.previous_telemetry = self.current_telemetry\n        self.current_telemetry = new_telemetry\n\n        logger.debug(\n            f\"New observations - State: {self.get_current_state()},\"\n            f\" Battery level: {self.current_telemetry.battery}/{self.current_telemetry.max_battery},\"\n            f\" Vel X,Y: {self.current_telemetry.vx}, {self.current_telemetry.vy},\"\n            f\" Fuel: {self.current_telemetry.fuel}\"\n        )\n\n        logger.debug(\n            \"Current memory usage: \"\n            + str(psutil.Process(os.getpid()).memory_info().rss / 1024**2)\n            + \" MB\"\n        )\n\n        # if self.get_current_state() == State.Acquisition:\n        #    await self.get_image()\n        # logger.debug(f\"Threads: {threading.active_count()}\")\n        # for thread in threading.enumerate():\n        #    frame = sys._current_frames()[thread.ident]\n        #    logger.warning(f\"{inspect.getframeinfo(frame).filename}.{inspect.getframeinfo(frame).function}:{inspect.getframeinfo(frame).lineno}\")\n\n        # check if still accelerating\n        if (\n            self._target_vel_x == self.current_telemetry.vx\n            and self._target_vel_y == self.current_telemetry.vy\n        ):\n            self._accelerating = False\n\n        if self.previous_telemetry is not None:\n            if self.get_previous_state() != self.get_current_state():\n                logger.info(\n                    f\"State changed from {self.get_previous_state()} to {self.get_current_state()}\"\n                )\n                self.previous_state = self.get_previous_state()\n                self.state_change_time = datetime.datetime.now()\n                # Put in here events to do on state change\n                if settings.TRACING:\n                    if self.previous_state == State.Transition:\n                        snapshot1 = tracemalloc.take_snapshot()\n                        stats = snapshot1.statistics(\"traceback\")\n                        for stat in stats:\n                            logger.warning(\n                                \"%s memory blocks: %.1f KiB\"\n                                % (stat.count, stat.size / 1024)\n                            )\n                            for line in stat.traceback.format():\n                                logger.warning(line)\n\n                # logger.debug(\n                #     f\"Previous state: {self.previous_state}, Current state: {self.get_current_state()}\"\n                # )\n                match self.get_current_state():\n                    case State.Transition:\n                        if self._run_get_image_task:\n                            logger.debug(\"end image\")\n                            self._run_get_image_task.cancel()\n                            self._run_get_image_task = None\n                        if self.submitted_transition_request:\n                            self.submitted_transition_request = False\n                        else:\n                            logger.warning(\"State transition was externally triggered!\")\n                    case State.Acquisition:\n                        logger.info(\"Starting control in acquisition state.\")\n                        if self._run_get_image_task:\n                            logger.debug(\"Image task already running\")\n                        else:\n                            logger.debug(\"start image\")\n                            loop = asyncio.get_event_loop()\n                            self._run_get_image_task = loop.create_task(\n                                self.run_get_image()\n                            )\n                        await self.control_acquisition()\n                    case State.Charge:\n                        pass\n                    case State.Safe:\n                        logger.warning(\"State transitioned to SAFE!\")\n                    case State.Communication:\n                        pass\n                    case State.Deployment:\n                        logger.warning(\"State transitioned to DEPLOYMENT!\")\n                    case _:\n                        logger.warning(f\"Unknown state {self.get_current_state()}\")\n                if self.get_current_state() != State.Acquisition:\n                    self._accelerating = False\n                if self.get_current_state() != State.Transition:\n                    if self.target_state != self.get_current_state():\n                        logger.warning(\n                            f\"Planned state transition to {self.target_state} failed, now in {self.get_current_state()}\"\n                        )\n                    else:\n                        logger.debug(\n                            f\"Planned state transition to {self.target_state} succeeded.\"\n                        )\n                    self.target_state = None\n\n            await self.plan_state_switching()\n\n    async def get_image(self) -&gt; None:\n        \"\"\"Captures an image if telemetry data is available and conditions are met.\n\n        If no telemetry data is available, the function waits for the next observation cycle.\n        It checks various conditions (e.g., acceleration, camera angle, timing) before fetching an image\n        from an external API and saving it with appropriate metadata.\n\n        Returns:\n            None\n        \"\"\"\n        logger.debug(\"Getting image\")\n        if self.current_telemetry is None:\n            logger.warning(\n                f\"No telemetry data available. Waiting {settings.OBSERVATION_REFRESH_RATE}s for next image.\"\n            )\n            image_task = Timer(\n                timeout=settings.OBSERVATION_REFRESH_RATE, callback=self.get_image\n            ).get_task()\n            await asyncio.gather(image_task)\n            return\n        if not self._aiohttp_session:\n            self._aiohttp_session = aiohttp.ClientSession()\n\n        # Filter out cases where no image should be taken\n\n        if (\n            settings.CURRENT_MELVIN_TASK == MELVINTask.Fixed_objective\n            or settings.CURRENT_MELVIN_TASK == MELVINTask.Next_objective\n        ) and not self._z_obj_list:\n            logger.warning(\n                \"Skipped image: In Objectives_only mode, but z_obj_list emtpy!\"\n            )\n            return\n\n        if self.current_telemetry.angle != settings.TARGET_CAMERA_ANGLE_ACQUISITION:\n            logger.info(\n                f\"Skipped image: current_angle={self.current_telemetry.angle} vs target={settings.TARGET_CAMERA_ANGLE_ACQUISITION}\"\n            )\n            return\n        if self._accelerating:\n            logger.info(\n                f\"Skipped image: accelerating to: {self._target_vel_x} {self._target_vel_y}\"\n            )\n            return\n\n        if settings.DO_TIMING_CHECK and settings.START_TIME &gt; datetime.datetime.now(\n            datetime.timezone.utc\n        ):\n            logger.warning(\n                f\"Skipped image, to early: start={settings.START_TIME} current_time={live_utc()}\"\n            )\n            return\n        if settings.DO_TIMING_CHECK and live_utc() &gt; settings.STOP_TIME:\n            logger.warning(\n                f\"Skipped image, to late: end={settings.STOP_TIME} current_time={live_utc()}\"\n            )\n            return\n\n        # save the current telemetry values, so they dont get overwritten by a later update\n        tele_timestamp = self.current_telemetry.timestamp\n        tele_x = self.current_telemetry.width_x\n        tele_y = self.current_telemetry.height_y\n        tele_vx = self.current_telemetry.vx\n        tele_vy = self.current_telemetry.vy\n        tele_simSpeed = self.get_simulation_speed()\n        tele_angle = self.current_telemetry.angle\n\n        lens_size = lens_size_by_angle(self.current_telemetry.angle)\n        \"\"\"\n        # TODO add box check if melvin and objective overlap\n        # check if we are in range of an objective\n        # TODO also check MELVINTasks\n        # TODO check if within box, unless hidden\n        melvin_box = (\n            tele_x - lens_size / 2,\n            tele_y - lens_size / 2,\n            tele_x + lens_size / 2,\n            tele_y + lens_size / 2,\n        )\n        if self._z_obj_list[0].zone is None:\n            logger.warning(\"Hidden objective, taking photo\")\n            return\n            TODO\n        else:\n            logger.warning(\"Checking if in range of objective:\")\n            objective_box = self._z_obj_list[0].zone\n\n        if not boxes_overlap_in_grid(melvin_box, objective_box):\n            logger.error(\n                f\"Image skipped, not Overlapping! {melvin_box} {objective_box}\"\n            )\n            return\n        \"\"\"\n        async with aiohttp.ClientSession() as session:\n            try:\n                async with session.get(con.IMAGE_ENDPOINT) as response:\n                    if response.status == 200:\n                        # Extract exact image timestamp\n                        img_timestamp = response.headers.get(\"image-timestamp\")\n                        if img_timestamp is None:\n                            logger.error(\n                                \"Image timestamp not found in headers, substituting with current time\"\n                            )\n                            parsed_img_timestamp = datetime.datetime.now()\n                        else:\n                            parsed_img_timestamp = datetime.datetime.fromisoformat(\n                                img_timestamp\n                            )\n\n                        # Calculate the difference between the img and the last telemetry\n                        difference_in_seconds = (\n                            parsed_img_timestamp - tele_timestamp\n                        ).total_seconds()\n\n                        adj_x = round(\n                            tele_x + (difference_in_seconds * tele_vx * tele_simSpeed)\n                        ) - (lens_size / 2)\n                        adj_y = round(\n                            tele_y + (difference_in_seconds * tele_vy * tele_simSpeed)\n                        ) - (lens_size / 2)\n\n                        # TODO check if images are correct!\n                        # TODO might also need modulo for side cases\n                        # logger.debug(f\"T {parsed_img_timestamp} | C {tele_timestamp}\")\n                        # logger.debug(\n                        #     f\"D {difference_in_seconds} | R {tele_x} ADJ {adj_x}\"\n                        # )\n\n                        image_path = con.IMAGE_LOCATION.format(\n                            melv_id=self._current_obj_name,\n                            angle=tele_angle,\n                            time=parsed_img_timestamp.strftime(\"%Y-%m-%dT%H:%M:%S.%f\"),\n                            cor_x=int(adj_x),\n                            cor_y=int(adj_y),\n                        )\n\n                        logger.info(\n                            f\"Received image at {adj_x}x {adj_y}y with {self.current_telemetry.angle} angle\"\n                        )\n\n                        async with async_open(image_path, \"wb\") as afp:\n                            while True:\n                                cnt = await response.content.readany()\n                                if not cnt:\n                                    break\n                                await afp.write(cnt)\n                    else:\n                        logger.warning(f\"Failed to get image: {response.status}\")\n                        logger.info(f\"Response body: {await response.text()}\")\n                        logger.info(\n                            \"This is normal at the end of acquisition mode once.\"\n                        )\n            except aiohttp.client_exceptions.ConnectionTimeoutError:\n                logger.warning(\"Observations endpoint timeouted.\")\n            except asyncio.exceptions.CancelledError:\n                logger.warning(\"Get image task was cancelled.\")\n\n    async def run_get_image(self) -&gt; None:\n        \"\"\"Continuously captures images while in the Acquisition state.\n\n        This function continuously captures images at calculated intervals,\n        adjusting timing based on velocity and acceleration.\n\n        Returns:\n            None\n        \"\"\"\n        logger.debug(\"Starting run_get_image\")\n        if self.get_current_state() == State.Acquisition:\n            await self.get_image()\n        while self.get_current_state() == State.Acquisition:\n            if self.current_telemetry is None:\n                logger.debug(\n                    \"No telemetry data available. Assuming Observation Refresh Rate.\"\n                )\n                delay_in_s = float(settings.OBSERVATION_REFRESH_RATE)\n            else:\n                current_total_vel = (\n                    self.current_telemetry.vx + self.current_telemetry.vy\n                )\n                if self._accelerating:\n                    # If accelerating calculate distance based on current speed and acceleration\n                    delay_in_s = (\n                        math.sqrt(\n                            current_total_vel**2\n                            + 2 * con.ACCELERATION * settings.DISTANCE_BETWEEN_IMAGES\n                        )\n                        - current_total_vel\n                    ) / con.ACCELERATION\n                else:\n                    # When not accelerating calculate distance based on current speed\n                    delay_in_s = (\n                        float(settings.DISTANCE_BETWEEN_IMAGES) / current_total_vel\n                    )\n            delay_in_s = delay_in_s / self.get_simulation_speed()\n            logger.debug(f\"Next image in {delay_in_s}s.\")\n            image_task = Timer(timeout=delay_in_s, callback=self.get_image).get_task()\n            await asyncio.gather(image_task)\n\n    # run once after changing into acquisition mode -&gt; setup\n    async def control_acquisition(self) -&gt; None:\n        \"\"\"Initializes acquisition mode by updating objectives and setting camera parameters.\n\n        Retrieves objectives from an external API, determines the current objective, and adjusts\n        acquisition parameters accordingly. Also creates necessary directories for image storage.\n\n        Returns:\n            None\n        \"\"\"\n        async with aiohttp.ClientSession() as session:\n            # update Objectives\n            async with session.get(con.OBJECTIVE_ENDPOINT) as response:\n                if response.status == 200:\n                    json_response = await response.json()\n                    self._z_obj_list: list[ZonedObjective] = ZonedObjective.parse_api(\n                        json_response\n                    )\n                    logger.info(\n                        f\"Updated objectives, there are {len(self._z_obj_list)} objectives.\"\n                    )\n                else:\n                    logger.error(\"Could not get OBJECTIVE_ENDPOINT\")\n\n        current_obj = None\n        # Always check for new objective in this task\n        if settings.CURRENT_MELVIN_TASK == MELVINTask.Next_objective:\n            current_obj = self._z_obj_list[0]\n\n            logger.error(f\"Using next_objective, current task: {current_obj.name}\")\n\n        # In this task look for the given string\n        elif settings.CURRENT_MELVIN_TASK == MELVINTask.Fixed_objective:\n            for obj in self._z_obj_list:\n                if obj.name == settings.FIXED_OBJECTIVE:\n                    logger.error(f\"Using fixed_objective, current task: {obj}\")\n                    current_obj = obj\n                    break\n\n        if current_obj:\n            settings.START_TIME = current_obj.start\n            settings.STOP_TIME = current_obj.end\n            settings.TARGET_CAMERA_ANGLE_ACQUISITION = current_obj.optic_required\n\n            self._current_obj_name = str(current_obj.id) + current_obj.name.replace(\n                \" \", \"\"\n            )\n\n            con.IMAGE_PATH = con.IMAGE_PATH_BASE + self._current_obj_name + \"/\"\n\n            con.IMAGE_LOCATION = (\n                con.IMAGE_PATH\n                + \"image_{melv_id}_{angle}_{time}_x_{cor_x}_y_{cor_y}.png\"\n            )\n            try:\n                subprocess.run([\"mkdir\", con.IMAGE_PATH], check=True)\n                logger.info(f\"Created folder: {con.IMAGE_PATH}\")\n\n            except subprocess.CalledProcessError as e:\n                logger.info(f\"z_obj could not mkdir: {e}\")\n\n        # check if change occured and cut the last image\n\n        await self.trigger_camera_angle_change(settings.TARGET_CAMERA_ANGLE_ACQUISITION)\n\n        # TODO stop velocity change if battery is low\n        if self.current_telemetry and self.current_telemetry.battery &lt; 10:\n            logger.error(\"Battery low, cant accelerate any more!\")\n\n        match settings.TARGET_CAMERA_ANGLE_ACQUISITION:\n            case CameraAngle.Wide:\n                await self.trigger_velocity_change(\n                    settings.TARGET_SPEED_WIDE_X, settings.TARGET_SPEED_WIDE_Y\n                )\n            case CameraAngle.Narrow:\n                await self.trigger_velocity_change(\n                    settings.TARGET_SPEED_NARROW_X, settings.TARGET_SPEED_NARROW_Y\n                )\n            case CameraAngle.Normal:\n                await self.trigger_velocity_change(\n                    settings.TARGET_SPEED_NORMAL_X, settings.TARGET_SPEED_NORMAL_Y\n                )\n            case _:\n                pass\n</code></pre>"},{"location":"melvonaut/#melvonaut.state_planer.StatePlanner.current_telemetry","title":"<code>current_telemetry = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.state_planer.StatePlanner.melv_id","title":"<code>melv_id = random.randint(0, 9999)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.state_planer.StatePlanner.previous_state","title":"<code>previous_state = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.state_planer.StatePlanner.previous_telemetry","title":"<code>previous_telemetry = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.state_planer.StatePlanner.recent_events","title":"<code>recent_events = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.state_planer.StatePlanner.state_change_time","title":"<code>state_change_time = datetime.datetime.now()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.state_planer.StatePlanner.submitted_transition_request","title":"<code>submitted_transition_request = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.state_planer.StatePlanner.target_state","title":"<code>target_state = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.state_planer.StatePlanner.calc_current_location","title":"<code>calc_current_location()</code>","text":"<p>Estimates the current location based on telemetry data and time elapsed.</p> <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>tuple[float, float]: The estimated (x, y) coordinates.</p> Source code in <code>src/melvonaut/state_planer.py</code> <pre><code>def calc_current_location(self) -&gt; tuple[float, float]:\n    \"\"\"Estimates the current location based on telemetry data and time elapsed.\n\n    Returns:\n        tuple[float, float]: The estimated (x, y) coordinates.\n    \"\"\"\n    if self.current_telemetry is None:\n        return 0.0, 0.0\n    time_since_observation = (\n        live_utc() - self.current_telemetry.timestamp\n    ).total_seconds()\n    current_x = (\n        self.current_telemetry.width_x\n        + self.current_telemetry.vx * time_since_observation\n    )\n    current_y = (\n        self.current_telemetry.height_y\n        + self.current_telemetry.vy * time_since_observation\n    )\n    return current_x, current_y\n</code></pre>"},{"location":"melvonaut/#melvonaut.state_planer.StatePlanner.calc_transition_remaining_time","title":"<code>calc_transition_remaining_time()</code>","text":"<p>Calculates the remaining time for state transition.</p> <p>Returns:</p> Type Description <code>timedelta</code> <p>datetime.timedelta: The remaining transition time based on the simulation speed.</p> Source code in <code>src/melvonaut/state_planer.py</code> <pre><code>def calc_transition_remaining_time(self) -&gt; datetime.timedelta:\n    \"\"\"Calculates the remaining time for state transition.\n\n    Returns:\n        datetime.timedelta: The remaining transition time based on the simulation speed.\n    \"\"\"\n    if self.get_current_state() is State.Transition:\n        logger.debug(\"Not in transition state, returning 0\")\n        return datetime.timedelta(0)\n    elif self.previous_state == State.Safe:\n        total_time = datetime.timedelta(\n            seconds=con.STATE_TRANSITION_FROM_SAFE_TIME\n            / self.get_simulation_speed()\n        )\n        return total_time - self.get_time_since_state_change()\n    else:\n        total_time = datetime.timedelta(\n            seconds=con.STATE_TRANSITION_TIME / self.get_simulation_speed()\n        )\n        return total_time - self.get_time_since_state_change()\n</code></pre>"},{"location":"melvonaut/#melvonaut.state_planer.StatePlanner.control_acquisition","title":"<code>control_acquisition()</code>  <code>async</code>","text":"<p>Initializes acquisition mode by updating objectives and setting camera parameters.</p> <p>Retrieves objectives from an external API, determines the current objective, and adjusts acquisition parameters accordingly. Also creates necessary directories for image storage.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/melvonaut/state_planer.py</code> <pre><code>async def control_acquisition(self) -&gt; None:\n    \"\"\"Initializes acquisition mode by updating objectives and setting camera parameters.\n\n    Retrieves objectives from an external API, determines the current objective, and adjusts\n    acquisition parameters accordingly. Also creates necessary directories for image storage.\n\n    Returns:\n        None\n    \"\"\"\n    async with aiohttp.ClientSession() as session:\n        # update Objectives\n        async with session.get(con.OBJECTIVE_ENDPOINT) as response:\n            if response.status == 200:\n                json_response = await response.json()\n                self._z_obj_list: list[ZonedObjective] = ZonedObjective.parse_api(\n                    json_response\n                )\n                logger.info(\n                    f\"Updated objectives, there are {len(self._z_obj_list)} objectives.\"\n                )\n            else:\n                logger.error(\"Could not get OBJECTIVE_ENDPOINT\")\n\n    current_obj = None\n    # Always check for new objective in this task\n    if settings.CURRENT_MELVIN_TASK == MELVINTask.Next_objective:\n        current_obj = self._z_obj_list[0]\n\n        logger.error(f\"Using next_objective, current task: {current_obj.name}\")\n\n    # In this task look for the given string\n    elif settings.CURRENT_MELVIN_TASK == MELVINTask.Fixed_objective:\n        for obj in self._z_obj_list:\n            if obj.name == settings.FIXED_OBJECTIVE:\n                logger.error(f\"Using fixed_objective, current task: {obj}\")\n                current_obj = obj\n                break\n\n    if current_obj:\n        settings.START_TIME = current_obj.start\n        settings.STOP_TIME = current_obj.end\n        settings.TARGET_CAMERA_ANGLE_ACQUISITION = current_obj.optic_required\n\n        self._current_obj_name = str(current_obj.id) + current_obj.name.replace(\n            \" \", \"\"\n        )\n\n        con.IMAGE_PATH = con.IMAGE_PATH_BASE + self._current_obj_name + \"/\"\n\n        con.IMAGE_LOCATION = (\n            con.IMAGE_PATH\n            + \"image_{melv_id}_{angle}_{time}_x_{cor_x}_y_{cor_y}.png\"\n        )\n        try:\n            subprocess.run([\"mkdir\", con.IMAGE_PATH], check=True)\n            logger.info(f\"Created folder: {con.IMAGE_PATH}\")\n\n        except subprocess.CalledProcessError as e:\n            logger.info(f\"z_obj could not mkdir: {e}\")\n\n    # check if change occured and cut the last image\n\n    await self.trigger_camera_angle_change(settings.TARGET_CAMERA_ANGLE_ACQUISITION)\n\n    # TODO stop velocity change if battery is low\n    if self.current_telemetry and self.current_telemetry.battery &lt; 10:\n        logger.error(\"Battery low, cant accelerate any more!\")\n\n    match settings.TARGET_CAMERA_ANGLE_ACQUISITION:\n        case CameraAngle.Wide:\n            await self.trigger_velocity_change(\n                settings.TARGET_SPEED_WIDE_X, settings.TARGET_SPEED_WIDE_Y\n            )\n        case CameraAngle.Narrow:\n            await self.trigger_velocity_change(\n                settings.TARGET_SPEED_NARROW_X, settings.TARGET_SPEED_NARROW_Y\n            )\n        case CameraAngle.Normal:\n            await self.trigger_velocity_change(\n                settings.TARGET_SPEED_NORMAL_X, settings.TARGET_SPEED_NORMAL_Y\n            )\n        case _:\n            pass\n</code></pre>"},{"location":"melvonaut/#melvonaut.state_planer.StatePlanner.get_current_state","title":"<code>get_current_state()</code>","text":"<p>Retrieves the current state from telemetry data.</p> <p>Returns:</p> Name Type Description <code>State</code> <code>State</code> <p>The current state if telemetry is available, otherwise State.Unknown.</p> Source code in <code>src/melvonaut/state_planer.py</code> <pre><code>def get_current_state(self) -&gt; State:\n    \"\"\"Retrieves the current state from telemetry data.\n\n    Returns:\n        State: The current state if telemetry is available, otherwise State.Unknown.\n    \"\"\"\n    if self.current_telemetry is None:\n        return State.Unknown\n    return self.current_telemetry.state\n</code></pre>"},{"location":"melvonaut/#melvonaut.state_planer.StatePlanner.get_image","title":"<code>get_image()</code>  <code>async</code>","text":"<p>Captures an image if telemetry data is available and conditions are met.</p> <p>If no telemetry data is available, the function waits for the next observation cycle. It checks various conditions (e.g., acceleration, camera angle, timing) before fetching an image from an external API and saving it with appropriate metadata.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/melvonaut/state_planer.py</code> <pre><code>async def get_image(self) -&gt; None:\n    \"\"\"Captures an image if telemetry data is available and conditions are met.\n\n    If no telemetry data is available, the function waits for the next observation cycle.\n    It checks various conditions (e.g., acceleration, camera angle, timing) before fetching an image\n    from an external API and saving it with appropriate metadata.\n\n    Returns:\n        None\n    \"\"\"\n    logger.debug(\"Getting image\")\n    if self.current_telemetry is None:\n        logger.warning(\n            f\"No telemetry data available. Waiting {settings.OBSERVATION_REFRESH_RATE}s for next image.\"\n        )\n        image_task = Timer(\n            timeout=settings.OBSERVATION_REFRESH_RATE, callback=self.get_image\n        ).get_task()\n        await asyncio.gather(image_task)\n        return\n    if not self._aiohttp_session:\n        self._aiohttp_session = aiohttp.ClientSession()\n\n    # Filter out cases where no image should be taken\n\n    if (\n        settings.CURRENT_MELVIN_TASK == MELVINTask.Fixed_objective\n        or settings.CURRENT_MELVIN_TASK == MELVINTask.Next_objective\n    ) and not self._z_obj_list:\n        logger.warning(\n            \"Skipped image: In Objectives_only mode, but z_obj_list emtpy!\"\n        )\n        return\n\n    if self.current_telemetry.angle != settings.TARGET_CAMERA_ANGLE_ACQUISITION:\n        logger.info(\n            f\"Skipped image: current_angle={self.current_telemetry.angle} vs target={settings.TARGET_CAMERA_ANGLE_ACQUISITION}\"\n        )\n        return\n    if self._accelerating:\n        logger.info(\n            f\"Skipped image: accelerating to: {self._target_vel_x} {self._target_vel_y}\"\n        )\n        return\n\n    if settings.DO_TIMING_CHECK and settings.START_TIME &gt; datetime.datetime.now(\n        datetime.timezone.utc\n    ):\n        logger.warning(\n            f\"Skipped image, to early: start={settings.START_TIME} current_time={live_utc()}\"\n        )\n        return\n    if settings.DO_TIMING_CHECK and live_utc() &gt; settings.STOP_TIME:\n        logger.warning(\n            f\"Skipped image, to late: end={settings.STOP_TIME} current_time={live_utc()}\"\n        )\n        return\n\n    # save the current telemetry values, so they dont get overwritten by a later update\n    tele_timestamp = self.current_telemetry.timestamp\n    tele_x = self.current_telemetry.width_x\n    tele_y = self.current_telemetry.height_y\n    tele_vx = self.current_telemetry.vx\n    tele_vy = self.current_telemetry.vy\n    tele_simSpeed = self.get_simulation_speed()\n    tele_angle = self.current_telemetry.angle\n\n    lens_size = lens_size_by_angle(self.current_telemetry.angle)\n    \"\"\"\n    # TODO add box check if melvin and objective overlap\n    # check if we are in range of an objective\n    # TODO also check MELVINTasks\n    # TODO check if within box, unless hidden\n    melvin_box = (\n        tele_x - lens_size / 2,\n        tele_y - lens_size / 2,\n        tele_x + lens_size / 2,\n        tele_y + lens_size / 2,\n    )\n    if self._z_obj_list[0].zone is None:\n        logger.warning(\"Hidden objective, taking photo\")\n        return\n        TODO\n    else:\n        logger.warning(\"Checking if in range of objective:\")\n        objective_box = self._z_obj_list[0].zone\n\n    if not boxes_overlap_in_grid(melvin_box, objective_box):\n        logger.error(\n            f\"Image skipped, not Overlapping! {melvin_box} {objective_box}\"\n        )\n        return\n    \"\"\"\n    async with aiohttp.ClientSession() as session:\n        try:\n            async with session.get(con.IMAGE_ENDPOINT) as response:\n                if response.status == 200:\n                    # Extract exact image timestamp\n                    img_timestamp = response.headers.get(\"image-timestamp\")\n                    if img_timestamp is None:\n                        logger.error(\n                            \"Image timestamp not found in headers, substituting with current time\"\n                        )\n                        parsed_img_timestamp = datetime.datetime.now()\n                    else:\n                        parsed_img_timestamp = datetime.datetime.fromisoformat(\n                            img_timestamp\n                        )\n\n                    # Calculate the difference between the img and the last telemetry\n                    difference_in_seconds = (\n                        parsed_img_timestamp - tele_timestamp\n                    ).total_seconds()\n\n                    adj_x = round(\n                        tele_x + (difference_in_seconds * tele_vx * tele_simSpeed)\n                    ) - (lens_size / 2)\n                    adj_y = round(\n                        tele_y + (difference_in_seconds * tele_vy * tele_simSpeed)\n                    ) - (lens_size / 2)\n\n                    # TODO check if images are correct!\n                    # TODO might also need modulo for side cases\n                    # logger.debug(f\"T {parsed_img_timestamp} | C {tele_timestamp}\")\n                    # logger.debug(\n                    #     f\"D {difference_in_seconds} | R {tele_x} ADJ {adj_x}\"\n                    # )\n\n                    image_path = con.IMAGE_LOCATION.format(\n                        melv_id=self._current_obj_name,\n                        angle=tele_angle,\n                        time=parsed_img_timestamp.strftime(\"%Y-%m-%dT%H:%M:%S.%f\"),\n                        cor_x=int(adj_x),\n                        cor_y=int(adj_y),\n                    )\n\n                    logger.info(\n                        f\"Received image at {adj_x}x {adj_y}y with {self.current_telemetry.angle} angle\"\n                    )\n\n                    async with async_open(image_path, \"wb\") as afp:\n                        while True:\n                            cnt = await response.content.readany()\n                            if not cnt:\n                                break\n                            await afp.write(cnt)\n                else:\n                    logger.warning(f\"Failed to get image: {response.status}\")\n                    logger.info(f\"Response body: {await response.text()}\")\n                    logger.info(\n                        \"This is normal at the end of acquisition mode once.\"\n                    )\n        except aiohttp.client_exceptions.ConnectionTimeoutError:\n            logger.warning(\"Observations endpoint timeouted.\")\n        except asyncio.exceptions.CancelledError:\n            logger.warning(\"Get image task was cancelled.\")\n</code></pre>"},{"location":"melvonaut/#melvonaut.state_planer.StatePlanner.get_previous_state","title":"<code>get_previous_state()</code>","text":"<p>Retrieves the previous state from telemetry data.</p> <p>Returns:</p> Name Type Description <code>State</code> <code>State</code> <p>The previous state if telemetry is available, otherwise State.Unknown.</p> Source code in <code>src/melvonaut/state_planer.py</code> <pre><code>def get_previous_state(self) -&gt; State:\n    \"\"\"Retrieves the previous state from telemetry data.\n\n    Returns:\n        State: The previous state if telemetry is available, otherwise State.Unknown.\n    \"\"\"\n    if self.previous_telemetry is None:\n        return State.Unknown\n    return self.previous_telemetry.state\n</code></pre>"},{"location":"melvonaut/#melvonaut.state_planer.StatePlanner.get_simulation_speed","title":"<code>get_simulation_speed()</code>","text":"<p>Gets the current simulation speed from telemetry data.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The simulation speed if telemetry is available, otherwise 1.</p> Source code in <code>src/melvonaut/state_planer.py</code> <pre><code>def get_simulation_speed(self) -&gt; int:\n    \"\"\"Gets the current simulation speed from telemetry data.\n\n    Returns:\n        int: The simulation speed if telemetry is available, otherwise 1.\n    \"\"\"\n    if self.current_telemetry is None:\n        return 1\n    return self.current_telemetry.simulation_speed\n</code></pre>"},{"location":"melvonaut/#melvonaut.state_planer.StatePlanner.get_time_since_state_change","title":"<code>get_time_since_state_change()</code>","text":"<p>Calculates the time elapsed since the last state change.</p> <p>Returns:</p> Type Description <code>timedelta</code> <p>datetime.timedelta: The time difference between now and the last state change.</p> Source code in <code>src/melvonaut/state_planer.py</code> <pre><code>def get_time_since_state_change(self) -&gt; datetime.timedelta:\n    \"\"\"Calculates the time elapsed since the last state change.\n\n    Returns:\n        datetime.timedelta: The time difference between now and the last state change.\n    \"\"\"\n    return datetime.datetime.now() - self.state_change_time\n</code></pre>"},{"location":"melvonaut/#melvonaut.state_planer.StatePlanner.model_post_init","title":"<code>model_post_init(__context__)</code>","text":"<p>Initializes the recent_events list by loading events from a CSV file.</p> <p>Parameters:</p> Name Type Description Default <code>__context__</code> <code>Any</code> <p>Context data passed during initialization.</p> required Source code in <code>src/melvonaut/state_planer.py</code> <pre><code>def model_post_init(self, __context__: Any) -&gt; None:\n    \"\"\"Initializes the recent_events list by loading events from a CSV file.\n\n    Args:\n        __context__ (Any): Context data passed during initialization.\n    \"\"\"\n    self.recent_events = Event.load_events_from_csv(path=con.EVENT_LOCATION_CSV)\n</code></pre>"},{"location":"melvonaut/#melvonaut.state_planer.StatePlanner.plan_state_switching","title":"<code>plan_state_switching()</code>  <code>async</code>","text":"<p>Plans and executes state transitions based on current telemetry data.</p> <p>This function checks the current state and decides whether to transition to another state based on conditions like battery level and velocity.</p> <p>Logs relevant debug information and triggers state transitions when necessary.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/melvonaut/state_planer.py</code> <pre><code>async def plan_state_switching(self) -&gt; None:\n    \"\"\"Plans and executes state transitions based on current telemetry data.\n\n    This function checks the current state and decides whether to transition\n    to another state based on conditions like battery level and velocity.\n\n    Logs relevant debug information and triggers state transitions when necessary.\n\n    Returns:\n        None\n    \"\"\"\n    if self.current_telemetry is None:\n        logger.warning(\"No telemetry data available. Cannot plan state switching.\")\n        return\n\n    state = self.get_current_state()\n\n    match state:\n        case State.Transition:\n            logger.debug(\n                f\"Time since state change: {self.get_time_since_state_change()}\"\n            )\n            expected_time_to_complete = self.calc_transition_remaining_time()\n            limited_log(\n                f\"State is Transition to {self.target_state}, waiting for transition to complete.\\nExpected time to complete state transition: {expected_time_to_complete}\"\n            )\n            # logger.debug(\n            #     f\"Previous state: {self.get_previous_state()}, Current state: {self.get_current_state()}\"\n            # )\n        case State.Acquisition:\n            # in EBT leave once everything is set\n            if settings.CURRENT_MELVIN_TASK == MELVINTask.EBT:\n                if (\n                    self._target_vel_x\n                    and self._target_vel_y\n                    and self.current_telemetry.angle\n                    == settings.TARGET_CAMERA_ANGLE_ACQUISITION\n                    and self._target_vel_x == self.current_telemetry.vx\n                    and self._target_vel_y == self.current_telemetry.vy\n                ):\n                    await self.trigger_state_transition(State.Communication)\n\n            await self.switch_if_battery_low(State.Charge, State.Acquisition)\n\n        case State.Charge:\n            if (\n                self.current_telemetry.battery\n                &gt;= self.current_telemetry.max_battery\n                - settings.BATTERY_HIGH_THRESHOLD\n            ):\n                if settings.CURRENT_MELVIN_TASK == MELVINTask.EBT:\n                    # starting ebt, but speed/angle not set yet\n\n                    logger.info(\n                        f\"EBT Task, Angle: telemetry: {self.current_telemetry.angle} vs target: {settings.TARGET_CAMERA_ANGLE_ACQUISITION}\"\n                    )\n                    logger.info(\n                        f\"EBT Task, vx: {self.current_telemetry.vx} vs target: {self._target_vel_x}\"\n                    )\n                    logger.info(\n                        f\"EBT Task, vy: {self.current_telemetry.vy} vs target: {self._target_vel_y}\"\n                    )\n                    if (\n                        self._target_vel_x is None\n                        or self._target_vel_y is None\n                        or self.current_telemetry.angle\n                        != settings.TARGET_CAMERA_ANGLE_ACQUISITION\n                        or self._target_vel_x != self.current_telemetry.vx\n                        or self._target_vel_y != self.current_telemetry.vy\n                    ):\n                        await self.trigger_state_transition(State.Acquisition)\n                    else:\n                        # logger.info(\"starting comms!\")\n                        await self.trigger_state_transition(State.Communication)\n\n                else:\n                    # logger.info(\"starting acq!\")\n                    await self.trigger_state_transition(State.Acquisition)\n\n        case State.Safe:\n            if self.current_telemetry.battery &gt;= (\n                self.current_telemetry.max_battery * 0.5\n            ):\n                await self.trigger_state_transition(State.Acquisition)\n            else:\n                await self.trigger_state_transition(State.Charge)\n            await self.switch_if_battery_low(State.Charge, State.Acquisition)\n        case State.Communication:\n            await self.switch_if_battery_low(State.Charge, State.Communication)\n        case State.Deployment:\n            logger.debug(\n                \"State is Deployment, triggering transition to Acquisition\"\n            )\n            await self.trigger_state_transition(State.Acquisition)\n</code></pre>"},{"location":"melvonaut/#melvonaut.state_planer.StatePlanner.run_get_image","title":"<code>run_get_image()</code>  <code>async</code>","text":"<p>Continuously captures images while in the Acquisition state.</p> <p>This function continuously captures images at calculated intervals, adjusting timing based on velocity and acceleration.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/melvonaut/state_planer.py</code> <pre><code>async def run_get_image(self) -&gt; None:\n    \"\"\"Continuously captures images while in the Acquisition state.\n\n    This function continuously captures images at calculated intervals,\n    adjusting timing based on velocity and acceleration.\n\n    Returns:\n        None\n    \"\"\"\n    logger.debug(\"Starting run_get_image\")\n    if self.get_current_state() == State.Acquisition:\n        await self.get_image()\n    while self.get_current_state() == State.Acquisition:\n        if self.current_telemetry is None:\n            logger.debug(\n                \"No telemetry data available. Assuming Observation Refresh Rate.\"\n            )\n            delay_in_s = float(settings.OBSERVATION_REFRESH_RATE)\n        else:\n            current_total_vel = (\n                self.current_telemetry.vx + self.current_telemetry.vy\n            )\n            if self._accelerating:\n                # If accelerating calculate distance based on current speed and acceleration\n                delay_in_s = (\n                    math.sqrt(\n                        current_total_vel**2\n                        + 2 * con.ACCELERATION * settings.DISTANCE_BETWEEN_IMAGES\n                    )\n                    - current_total_vel\n                ) / con.ACCELERATION\n            else:\n                # When not accelerating calculate distance based on current speed\n                delay_in_s = (\n                    float(settings.DISTANCE_BETWEEN_IMAGES) / current_total_vel\n                )\n        delay_in_s = delay_in_s / self.get_simulation_speed()\n        logger.debug(f\"Next image in {delay_in_s}s.\")\n        image_task = Timer(timeout=delay_in_s, callback=self.get_image).get_task()\n        await asyncio.gather(image_task)\n</code></pre>"},{"location":"melvonaut/#melvonaut.state_planer.StatePlanner.switch_if_battery_low","title":"<code>switch_if_battery_low(state_low_battery, state_high_battery)</code>  <code>async</code>","text":"<p>Switches state based on battery level.</p> <p>Parameters:</p> Name Type Description Default <code>state_low_battery</code> <code>State</code> <p>The state to switch to when battery is low.</p> required <code>state_high_battery</code> <code>State</code> <p>The state to switch to when battery is sufficient.</p> required Source code in <code>src/melvonaut/state_planer.py</code> <pre><code>async def switch_if_battery_low(\n    self, state_low_battery: State, state_high_battery: State\n) -&gt; None:\n    \"\"\"Switches state based on battery level.\n\n    Args:\n        state_low_battery (State): The state to switch to when battery is low.\n        state_high_battery (State): The state to switch to when battery is sufficient.\n    \"\"\"\n    if self.current_telemetry is None:\n        logger.warning(\n            \"No telemetry data available. Cannot plan battery based switching.\"\n        )\n        return\n    if self.current_telemetry.battery &lt;= settings.BATTERY_LOW_THRESHOLD:\n        if self.get_current_state() == state_low_battery:\n            return\n        logger.debug(\n            f\"State is {self.get_current_state()}, Battery is low, triggering transition to {state_low_battery}\"\n        )\n        await self.trigger_state_transition(state_low_battery)\n    else:\n        if self.get_current_state() == state_high_battery:\n            return\n        logger.debug(\n            f\"State is {self.get_current_state()}, Battery is high, triggering transition to {state_high_battery}\"\n        )\n        await self.trigger_state_transition(state_high_battery)\n</code></pre>"},{"location":"melvonaut/#melvonaut.state_planer.StatePlanner.trigger_camera_angle_change","title":"<code>trigger_camera_angle_change(new_angle)</code>  <code>async</code>","text":"<p>Tries to change the camera angle to new_angle</p> <p>Parameters:</p> Name Type Description Default <code>new_angle</code> <code>CameraAngle</code> <p>The desired camera angle.</p> required Source code in <code>src/melvonaut/state_planer.py</code> <pre><code>async def trigger_camera_angle_change(self, new_angle: CameraAngle) -&gt; None:\n    \"\"\"Tries to change the camera angle to new_angle\n\n    Args:\n        new_angle (CameraAngle): The desired camera angle.\n    \"\"\"\n    if self.current_telemetry is None:\n        logger.warning(\"No telemetry data available. Cannot set camera angle.\")\n        return\n    if new_angle == self.current_telemetry.angle:\n        logger.info(\"Target camera angle already set. Not changing angle.\")\n        return\n    request_body = {\n        \"vel_x\": self.current_telemetry.vx,\n        \"vel_y\": self.current_telemetry.vy,\n        \"camera_angle\": new_angle,\n        \"state\": self.get_current_state(),\n    }\n    async with aiohttp.ClientSession() as session:\n        async with session.put(con.CONTROL_ENDPOINT, json=request_body) as response:\n            if response.status == 200:\n                self.current_telemetry.angle = new_angle\n                logger.info(f\"Camera angle set to {new_angle}\")\n            else:\n                logger.error(f\"Failed to set camera angle to {new_angle}\")\n</code></pre>"},{"location":"melvonaut/#melvonaut.state_planer.StatePlanner.trigger_state_transition","title":"<code>trigger_state_transition(new_state)</code>  <code>async</code>","text":"<p>Initiates a state transition if valid conditions are met.</p> <p>Parameters:</p> Name Type Description Default <code>new_state</code> <code>State</code> <p>The target state to transition to.</p> required Source code in <code>src/melvonaut/state_planer.py</code> <pre><code>async def trigger_state_transition(self, new_state: State) -&gt; None:\n    \"\"\"Initiates a state transition if valid conditions are met.\n\n    Args:\n        new_state (State): The target state to transition to.\n    \"\"\"\n    if new_state in [State.Transition, State.Unknown, State.Deployment, State.Safe]:\n        logger.warning(f\"Cannot transition to {new_state}.\")\n        return\n    if self.current_telemetry is None:\n        logger.warning(\"No telemetry data available. Cannot initiate transition.\")\n        return\n    if self.current_telemetry.state == State.Transition:\n        logger.debug(\"Already in transition state, not starting transition.\")\n        return\n    if new_state == self.get_current_state():\n        logger.debug(f\"State is already {new_state}, not starting transition.\")\n        return\n    request_body = {\n        \"state\": new_state,\n        \"vel_x\": self.current_telemetry.vx,\n        \"vel_y\": self.current_telemetry.vy,\n        \"camera_angle\": self.current_telemetry.angle,\n    }\n    async with aiohttp.ClientSession() as session:\n        async with session.put(con.CONTROL_ENDPOINT, json=request_body) as response:\n            if response.status == 200:\n                logger.info(\n                    f\"Started transition to {new_state} at battery level {self.current_telemetry.battery}\"\n                )\n                self.submitted_transition_request = True\n                self.target_state = new_state\n            else:\n                logger.warning(\n                    f\"Failed to transition to {new_state}: {response.status}\"\n                )\n                logger.debug(f\"Response body: {await response.text()}\")\n</code></pre>"},{"location":"melvonaut/#melvonaut.state_planer.StatePlanner.trigger_velocity_change","title":"<code>trigger_velocity_change(new_vel_x, new_vel_y)</code>  <code>async</code>","text":"<p>Sets new values for accelartion, also set _accelerating</p> <p>Parameters:</p> Name Type Description Default <code>new_vel_x</code> <code>float</code> <p>The target velocity in the x direction.</p> required <code>new_vel_y</code> <code>float</code> <p>The target velocity in the y direction.</p> required Source code in <code>src/melvonaut/state_planer.py</code> <pre><code>async def trigger_velocity_change(self, new_vel_x: float, new_vel_y: float) -&gt; None:\n    \"\"\"Sets new values for accelartion, also set _accelerating\n\n    Args:\n        new_vel_x (float): The target velocity in the x direction.\n        new_vel_y (float): The target velocity in the y direction.\n    \"\"\"\n\n    self._target_vel_x = new_vel_x\n    self._target_vel_y = new_vel_y\n\n    if self.current_telemetry is None:\n        logger.warning(\"No telemetry data available. Cannot set velocity.\")\n        return\n    if (\n        new_vel_x == self.current_telemetry.vx\n        and new_vel_y == self.current_telemetry.vy\n    ):\n        self._accelerating = False\n        logger.info(\"Target velocity already set. Not changing velocity.\")\n        return\n    request_body = {\n        \"vel_x\": new_vel_x,\n        \"vel_y\": new_vel_y,\n        \"camera_angle\": self.current_telemetry.angle,\n        \"state\": self.get_current_state(),\n    }\n    async with aiohttp.ClientSession() as session:\n        async with session.put(con.CONTROL_ENDPOINT, json=request_body) as response:\n            if response.status == 200:\n                self._accelerating = True\n                logger.info(f\"Velocity set to {new_vel_x}, {new_vel_y}\")\n            else:\n                logger.error(f\"Failed to set velocity to {new_vel_x}, {new_vel_y}\")\n</code></pre>"},{"location":"melvonaut/#melvonaut.state_planer.StatePlanner.update_telemetry","title":"<code>update_telemetry(new_telemetry)</code>  <code>async</code>","text":"<p>Updates the telemetry data and handles state changes.</p> <p>This function updates the previous and current telemetry readings, logs relevant debug information, and checks for state changes.</p> <p>If a state change occurs, it logs the transition, cancels image retrieval tasks if necessary, and triggers appropriate actions based on the new state.</p> <p>Parameters:</p> Name Type Description Default <code>new_telemetry</code> <code>MelTelemetry</code> <p>The new telemetry data to update.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/melvonaut/state_planer.py</code> <pre><code>async def update_telemetry(self, new_telemetry: MelTelemetry) -&gt; None:\n    \"\"\"Updates the telemetry data and handles state changes.\n\n    This function updates the previous and current telemetry readings,\n    logs relevant debug information, and checks for state changes.\n\n    If a state change occurs, it logs the transition, cancels image\n    retrieval tasks if necessary, and triggers appropriate actions based on\n    the new state.\n\n    Args:\n        new_telemetry (MelTelemetry): The new telemetry data to update.\n\n    Returns:\n        None\n    \"\"\"\n    self.previous_telemetry = self.current_telemetry\n    self.current_telemetry = new_telemetry\n\n    logger.debug(\n        f\"New observations - State: {self.get_current_state()},\"\n        f\" Battery level: {self.current_telemetry.battery}/{self.current_telemetry.max_battery},\"\n        f\" Vel X,Y: {self.current_telemetry.vx}, {self.current_telemetry.vy},\"\n        f\" Fuel: {self.current_telemetry.fuel}\"\n    )\n\n    logger.debug(\n        \"Current memory usage: \"\n        + str(psutil.Process(os.getpid()).memory_info().rss / 1024**2)\n        + \" MB\"\n    )\n\n    # if self.get_current_state() == State.Acquisition:\n    #    await self.get_image()\n    # logger.debug(f\"Threads: {threading.active_count()}\")\n    # for thread in threading.enumerate():\n    #    frame = sys._current_frames()[thread.ident]\n    #    logger.warning(f\"{inspect.getframeinfo(frame).filename}.{inspect.getframeinfo(frame).function}:{inspect.getframeinfo(frame).lineno}\")\n\n    # check if still accelerating\n    if (\n        self._target_vel_x == self.current_telemetry.vx\n        and self._target_vel_y == self.current_telemetry.vy\n    ):\n        self._accelerating = False\n\n    if self.previous_telemetry is not None:\n        if self.get_previous_state() != self.get_current_state():\n            logger.info(\n                f\"State changed from {self.get_previous_state()} to {self.get_current_state()}\"\n            )\n            self.previous_state = self.get_previous_state()\n            self.state_change_time = datetime.datetime.now()\n            # Put in here events to do on state change\n            if settings.TRACING:\n                if self.previous_state == State.Transition:\n                    snapshot1 = tracemalloc.take_snapshot()\n                    stats = snapshot1.statistics(\"traceback\")\n                    for stat in stats:\n                        logger.warning(\n                            \"%s memory blocks: %.1f KiB\"\n                            % (stat.count, stat.size / 1024)\n                        )\n                        for line in stat.traceback.format():\n                            logger.warning(line)\n\n            # logger.debug(\n            #     f\"Previous state: {self.previous_state}, Current state: {self.get_current_state()}\"\n            # )\n            match self.get_current_state():\n                case State.Transition:\n                    if self._run_get_image_task:\n                        logger.debug(\"end image\")\n                        self._run_get_image_task.cancel()\n                        self._run_get_image_task = None\n                    if self.submitted_transition_request:\n                        self.submitted_transition_request = False\n                    else:\n                        logger.warning(\"State transition was externally triggered!\")\n                case State.Acquisition:\n                    logger.info(\"Starting control in acquisition state.\")\n                    if self._run_get_image_task:\n                        logger.debug(\"Image task already running\")\n                    else:\n                        logger.debug(\"start image\")\n                        loop = asyncio.get_event_loop()\n                        self._run_get_image_task = loop.create_task(\n                            self.run_get_image()\n                        )\n                    await self.control_acquisition()\n                case State.Charge:\n                    pass\n                case State.Safe:\n                    logger.warning(\"State transitioned to SAFE!\")\n                case State.Communication:\n                    pass\n                case State.Deployment:\n                    logger.warning(\"State transitioned to DEPLOYMENT!\")\n                case _:\n                    logger.warning(f\"Unknown state {self.get_current_state()}\")\n            if self.get_current_state() != State.Acquisition:\n                self._accelerating = False\n            if self.get_current_state() != State.Transition:\n                if self.target_state != self.get_current_state():\n                    logger.warning(\n                        f\"Planned state transition to {self.target_state} failed, now in {self.get_current_state()}\"\n                    )\n                else:\n                    logger.debug(\n                        f\"Planned state transition to {self.target_state} succeeded.\"\n                    )\n                self.target_state = None\n\n        await self.plan_state_switching()\n</code></pre>"},{"location":"melvonaut/#melvonaut.utils","title":"<code>utils</code>","text":""},{"location":"melvonaut/#melvonaut.utils.file_log_handler_id","title":"<code>file_log_handler_id = None</code>  <code>module-attribute</code>","text":""},{"location":"melvonaut/#melvonaut.utils.melvin_notifier","title":"<code>melvin_notifier(body, title, notify_type, *args, **kwargs)</code>","text":"<p>Melvin-specific notification handler.</p> <p>Just prints to stdout.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>str</code> <p>The message body.</p> required <code>title</code> <code>str</code> <p>The notification title.</p> required <code>notify_type</code> <code>NotifyType</code> <p>The type of notification.</p> required <code>*args</code> <code>Any</code> <p>Additional arguments.</p> <code>()</code> <code>**kwargs</code> <code>dict[str, Any]</code> <p>Additional keyword arguments.</p> <code>{}</code> Source code in <code>src/melvonaut/utils.py</code> <pre><code>@apprise.decorators.notify(on=\"melvin\")  # type: ignore\ndef melvin_notifier(\n    body: str, title: str, notify_type: NotifyType, *args: Any, **kwargs: dict[str, Any]\n) -&gt; None:\n    \"\"\"Melvin-specific notification handler.\n\n    Just prints to stdout.\n\n    Args:\n        body (str): The message body.\n        title (str): The notification title.\n        notify_type (NotifyType): The type of notification.\n        *args (Any): Additional arguments.\n        **kwargs (dict[str, Any]): Additional keyword arguments.\n    \"\"\"\n    print(\"MELVIN HERE!\")\n</code></pre>"},{"location":"melvonaut/#melvonaut.utils.setup_file_logging","title":"<code>setup_file_logging()</code>","text":"<p>Configures file-based logging with rotation at midnight.</p> <p>If a file log handler already exists, it is removed before adding a new one.</p> Source code in <code>src/melvonaut/utils.py</code> <pre><code>def setup_file_logging() -&gt; None:\n    \"\"\"Configures file-based logging with rotation at midnight.\n\n    If a file log handler already exists, it is removed before adding a new one.\n    \"\"\"\n    global file_log_handler_id\n    if file_log_handler_id is not None:\n        logger.remove(file_log_handler_id)  # type: ignore\n    file_log_handler_id = logger.add(\n        sink=con.MEL_LOG_LOCATION,\n        rotation=\"00:00\",\n        level=settings.FILE_LOGGING_LEVEL,\n        backtrace=True,\n        diagnose=True,\n        enqueue=True,\n    )\n</code></pre>"},{"location":"melvonaut/#melvonaut.utils.setup_logging","title":"<code>setup_logging()</code>","text":"<p>Configures the logging system for the application.</p> <p>This function removes existing log handlers, sets up terminal logging, and configures Apprise notifications for Discord and Melvin events.</p> Source code in <code>src/melvonaut/utils.py</code> <pre><code>def setup_logging() -&gt; None:\n    \"\"\"Configures the logging system for the application.\n\n    This function removes existing log handlers, sets up terminal logging,\n    and configures Apprise notifications for Discord and Melvin events.\n    \"\"\"\n    logger.remove()\n    logger.add(\n        sink=sys.stdout,\n        level=settings.TERMINAL_LOGGING_LEVEL,\n        backtrace=True,\n        diagnose=True,\n        enqueue=True,\n    )\n    notifier = apprise.Apprise()\n    if settings.DISCORD_WEBHOOK_TOKEN and settings.DISCORD_ALERTS_ENABLED:\n        notifier.add(f\"discord://{settings.DISCORD_WEBHOOK_TOKEN}\")\n        logger.add(notifier.notify, level=\"ERROR\", filter={\"apprise\": False})  # type: ignore\n\n    if settings.NETWORK_SIM_ENABLED:\n        notifier.add(\"melvin://\")\n        logger.add(notifier.notify, level=\"ERROR\", filter={\"apprise\": False})  # type: ignore\n\n    setup_file_logging()\n</code></pre>"},{"location":"rift_console/","title":"Rift-Console Reference","text":"<p>Ciarc.</p>"},{"location":"rift_console/#rift_console.image_helper","title":"<code>image_helper</code>","text":"<p>Provides helping functions that are used in image_processing.</p>"},{"location":"rift_console/#rift_console.image_helper.filter_by_date","title":"<code>filter_by_date(images, start, end)</code>","text":"Source code in <code>src/rift_console/image_helper.py</code> <pre><code>def filter_by_date(\n    images: list[str], start: datetime.datetime, end: datetime.datetime\n) -&gt; list[str]:\n    res = []\n    date_format = \"%Y-%m-%dT%H:%M:%S\"\n    for image in images:\n        date = datetime.datetime.strptime(get_date(image), date_format).replace(\n            tzinfo=datetime.timezone.utc\n        )\n        # logger.warning(f\"{date} {start} {end}\")\n        if date &gt;= start and date &lt;= end:\n            res.append(image)\n    return res\n</code></pre>"},{"location":"rift_console/#rift_console.image_helper.find_image_names","title":"<code>find_image_names(directory)</code>","text":"<p>Traverses the given directory and find + sorts all images in our filename format</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str</code> <p>path to the folder, needs to include con.IMAGE_PATH</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: the name of all images in that folder, sorted by its timestamp from old to now</p> Source code in <code>src/rift_console/image_helper.py</code> <pre><code>def find_image_names(directory: str) -&gt; list[str]:\n    \"\"\"Traverses the given directory and find + sorts all images in our filename format\n\n    Args:\n        directory (str): path to the folder, needs to include con.IMAGE_PATH\n\n    Returns:\n        list[str]: the name of all images in that folder, sorted by its timestamp from old to now\n    \"\"\"\n\n    # find all names\n    image_names = []\n    for filename in os.listdir(directory):\n        if filename.startswith(\"image\"):\n            image_names.append(filename)\n\n    # helper function used in sorting\n    def extract_timestamp(s: str) -&gt; datetime.datetime:\n        timestamp_pattern = r\"_(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{6})\"\n\n        match = re.search(timestamp_pattern, s)\n        if match:\n            return datetime.datetime.fromisoformat(match.group(1))\n        else:\n            raise Exception(\"find_image_names: did not found timestamp in image names\")\n\n    def extract_pos(s: str) -&gt; int:\n        pos_pattern = r\"_x_(-?\\d+)_y_(-?\\d+)\"\n\n        match = re.search(pos_pattern, s)\n        if match:\n            x = int(match.group(1))\n            y = int(match.group(2))\n            return x + y\n        else:\n            raise Exception(\"find_image_names: did not found position in image names\")\n\n    # sort\n    if con.SORT_IMAGE_BY_POSITION:\n        image_names = sorted(image_names, key=extract_pos)\n    else:\n        image_names = sorted(image_names, key=extract_timestamp)\n    return image_names\n</code></pre>"},{"location":"rift_console/#rift_console.image_helper.generate_spiral_walk","title":"<code>generate_spiral_walk(n)</code>","text":"<p>Create an spiraling offset pattern arround a central point, e.g. (0,0), (0,1), (1,0), (1,1), ...     sorted by Manhattan geometry</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>number of offsets to be generated</p> required <p>Returns:</p> Type Description <code>list[tuple[int, int]]</code> <p>list[tuple[int, int]]: list of offsets</p> Source code in <code>src/rift_console/image_helper.py</code> <pre><code>def generate_spiral_walk(n: int) -&gt; list[tuple[int, int]]:\n    \"\"\"Create an spiraling offset pattern arround a central point, e.g. (0,0), (0,1), (1,0), (1,1), ...\n        sorted by Manhattan geometry\n\n    Args:\n        n (int): number of offsets to be generated\n\n    Returns:\n        list[tuple[int, int]]: list of offsets\n    \"\"\"\n\n    # move right, up, left, down\n    directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n    # start with going right\n    direction_index = 0\n\n    x, y = 0, 0\n    offsets = [(x, y)]\n\n    # Number of steps we take before changing direction\n    steps = 1\n\n    while len(offsets) &lt; n:\n        for _ in range(2):\n            for _ in range(steps):\n                if len(offsets) &lt; n:\n                    # Move in the current direction\n                    dx, dy = directions[direction_index]\n                    x += dx\n                    y += dy\n                    # Add the new position to the spiral\n                    offsets.append((x, y))\n                else:\n                    break\n            # Change direction clockwise\n            direction_index = (direction_index + 1) % 4\n        # After moving two directions, we increase the number of steps\n        steps += 1\n\n    sorted_offset = sorted(offsets, key=lambda x: abs(x[0]) + abs(x[1]))\n    return sorted_offset\n</code></pre>"},{"location":"rift_console/#rift_console.image_helper.get_angle","title":"<code>get_angle(image)</code>","text":"Source code in <code>src/rift_console/image_helper.py</code> <pre><code>def get_angle(image: str) -&gt; CameraAngle:\n    if \"narrow\" in image:\n        return CameraAngle.Narrow\n    elif \"normal\" in image:\n        return CameraAngle.Normal\n    elif \"wide\" in image:\n        return CameraAngle.Wide\n    logger.warning(f\"Unknown camera angle in {image}\")\n    return CameraAngle.Unknown\n</code></pre>"},{"location":"rift_console/#rift_console.image_helper.get_date","title":"<code>get_date(image)</code>","text":"Source code in <code>src/rift_console/image_helper.py</code> <pre><code>def get_date(image: str) -&gt; str:\n    # pattern of year-month-dayThour-minute\n    pattern = r\"\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\"\n\n    found_matches = re.findall(pattern, image)\n\n    if len(found_matches) == 1:\n        # logger.debug(found_matches[0])\n        match: str = found_matches[0]\n        return match\n    else:\n        logger.warning(\"None or two dates in {image}\")\n        return datetime.datetime.min.strftime(\"%Y-%m-%dT%H:%M:%S\")\n</code></pre>"},{"location":"rift_console/#rift_console.image_helper.parse_image_name","title":"<code>parse_image_name(name)</code>","text":"<p>Parses an image name in the format generated by Melvonaut and extract the relevant properties for stitching</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>file name of the image</p> required <p>Returns:</p> Type Description <code>int</code> <p>tuple[int, int, int]: Used lenssize (and therefore if the image should be scaled to this later)</p> <code>int</code> <p>and approximated x/y coordinates on the stiched image</p> Source code in <code>src/rift_console/image_helper.py</code> <pre><code>def parse_image_name(name: str) -&gt; tuple[int, int, int]:\n    \"\"\"Parses an image name in the format generated by Melvonaut and extract the relevant properties for stitching\n\n    Args:\n        name (str): file name of the image\n\n    Returns:\n        tuple[int, int, int]: Used lenssize (and therefore if the image should be scaled to this later)\n        and approximated x/y coordinates on the stiched image\n    \"\"\"\n    from shared.models import CameraAngle\n\n    # expected format: 'image_5344_wide_2024-12-11T17:31:27.507376_x_19936_y_4879'\n    # with 8 underscores\n    if len(name.split(\"_\")) != con.IMAGE_NAME_UNDERSCORE_COUNT:\n        raise Exception(\"parse_image_name: filename has wrong format!\")\n\n    # used CameraAngle is after second underscore\n    match name.split(\"_\")[con.IMAGE_ANGLE_POSITION]:\n        case CameraAngle.Narrow:\n            lens_size = 600\n        case CameraAngle.Normal:\n            lens_size = 800\n        case CameraAngle.Wide:\n            lens_size = 1000\n\n    # find x and y in name\n    match = re.search(r\"_x_(-?\\d+)_y_(-?\\d+)\", name)\n\n    if match:\n        x = int(match.group(1))\n        y = int(match.group(2))\n\n        # old images position is not adjusted in melvonaut yet\n        if con.USE_LEGACY_IMAGE_NAMES:\n            x -= (int)(lens_size / 2)\n            y -= (int)(lens_size / 2)\n    else:\n        raise Exception(\"parse_image_name: could not match x/y coordinates!\")\n\n    return lens_size, x, y\n</code></pre>"},{"location":"rift_console/#rift_console.image_processing","title":"<code>image_processing</code>","text":""},{"location":"rift_console/#rift_console.image_processing.automated_stitching","title":"<code>automated_stitching(local_path)</code>","text":"<p>Stitches images from the given path into one big image, which is stored under the same name in con.PANORAMA_PATH.</p> <p>Parameters:</p> Name Type Description Default <code>local_path</code> <code>str</code> <p>Path of a folder with images that should be stitched.</p> required Source code in <code>src/rift_console/image_processing.py</code> <pre><code>def automated_stitching(local_path: str) -&gt; None:\n    \"\"\"Stitches images from the given path into one big image, which is stored under the same name in con.PANORAMA_PATH.\n\n    Args:\n        local_path (str): Path of a folder with images that should be stitched.\n    \"\"\"\n\n    image_path = local_path + \"/\"\n    output_path = con.PANORAMA_PATH + \"stitched\"\n\n    image_name_list = find_image_names(image_path)\n\n    logger.warning(\n        f\"Starting stitching of {len(image_name_list)} image with path: {image_path}\"\n    )\n\n    panorama = stitch_images(image_path=image_path, image_name_list=image_name_list)\n\n    remove_offset = (\n        con.STITCHING_BORDER,\n        con.STITCHING_BORDER,\n        con.WORLD_X + con.STITCHING_BORDER,\n        con.WORLD_Y + con.STITCHING_BORDER,\n    )\n    panorama = panorama.crop(remove_offset)\n    panorama.save(output_path + \".png\")\n\n    logger.warning(f\"Saved panorama in {output_path}.png\")\n</code></pre>"},{"location":"rift_console/#rift_console.image_processing.count_matching_pixels","title":"<code>count_matching_pixels(offset, first_img, second_img, max_offset)</code>","text":"<p>Counts how many pixels are equal between the two images for a given offset</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>tuple[int, int]</code> <p>shift of one image</p> required <code>img</code> <code>Image</code> <p>first image</p> required <code>existing_img</code> <code>Image</code> <p>second (larger to allow shift) image</p> required <p>Returns:</p> Type Description <code>tuple[tuple[int, int], int]</code> <p>tuple[int, int]: used offset and number of matching pixels</p> Source code in <code>src/rift_console/image_processing.py</code> <pre><code>def count_matching_pixels(\n    offset: tuple[int, int],\n    first_img: Image.Image,\n    second_img: Image.Image,\n    max_offset: int,\n) -&gt; tuple[tuple[int, int], int]:\n    \"\"\"Counts how many pixels are equal between the two images for a given offset\n\n    Args:\n        offset (tuple[int, int]): shift of one image\n        img (Image): first image\n        existing_img (Image): second (larger to allow shift) image\n\n    Returns:\n        tuple[int, int]: used offset and number of matching pixels\n    \"\"\"\n\n    matches = 0\n    for x_local in range(first_img.size[0]):\n        for y_local in range(first_img.size[1]):\n            p1 = first_img.getpixel((x_local, y_local))\n            p2 = second_img.getpixel(\n                (x_local + offset[0] + max_offset, y_local + offset[1] + max_offset)\n            )\n            if p1 and p2 and isinstance(p1, tuple) and isinstance(p2, tuple):\n                # only compare R G B and not Alpha. Since there is random noise a slight difference is allowed\n                if (\n                    abs(p1[0] - p2[0]) + abs(p1[1] - p2[1]) + abs(p1[2] - p2[2])\n                    &lt; con.IMAGE_NOISE_FORGIVENESS\n                ):\n                    matches += 1\n            else:\n                logger.error(f\"{p1} {p2} unkown types\")\n\n    return offset, matches\n</code></pre>"},{"location":"rift_console/#rift_console.image_processing.create_thumbnail","title":"<code>create_thumbnail(panorama_path)</code>","text":"<p>Creates a scaled down panorama and a greyscale one from a given panorama and saves it to <code>src/rift_console/static/images/thumb.png</code> from where it can be used by html.</p> <p>Parameters:</p> Name Type Description Default <code>panorama_path</code> <code>str</code> <p>Name of the file (should include con.PANORAMA_PATH)</p> required Source code in <code>src/rift_console/image_processing.py</code> <pre><code>def create_thumbnail(panorama_path: str) -&gt; None:\n    \"\"\"Creates a scaled down panorama and a greyscale one from a given panorama and saves it to `src/rift_console/static/images/thumb.png` from where it can be used by html.\n\n    Args:\n        panorama_path (str): Name of the file (should include con.PANORAMA_PATH)\n    \"\"\"\n    with Image.open(panorama_path) as panorama:\n        thumb = panorama.resize(\n            (con.THUMBNAIL_X, con.THUMBNAIL_Y), Image.Resampling.LANCZOS\n        )\n        thumb.save(panorama_path.replace(\".png\", \"\") + \"_thumb.png\")\n        # thumb = thumb.convert(\"L\")\n        # thumb.save(\"src/rift_console/static/images/\" + \"thumb_grey.png\")\n    logger.warning(f\"Saved Thumbnail to {panorama_path}_thumb.png\")\n</code></pre>"},{"location":"rift_console/#rift_console.image_processing.cut","title":"<code>cut(panorama_path, X1, Y1, X2, Y2)</code>","text":"<p>Cut a small portion from a bigger Panorama.</p> <p>Parameters:</p> Name Type Description Default <code>panorama_path</code> <code>str</code> <p>Name of the file (should include con.PANORAMA_PATH)</p> required <code>coordinates</code> <p>Section that should be cut and saved</p> required Source code in <code>src/rift_console/image_processing.py</code> <pre><code>def cut(panorama_path: str, X1: int, Y1: int, X2: int, Y2: int) -&gt; None:\n    \"\"\"Cut a small portion from a bigger Panorama.\n\n    Args:\n        panorama_path (str): Name of the file (should include con.PANORAMA_PATH)\n        coordinates: Section that should be cut and saved\n    \"\"\"\n    coordinates = (int(X1), int(Y1), int(X2), int(Y2))\n    with Image.open(panorama_path) as panorama:\n        cut_img = panorama.crop(coordinates)\n\n    # cut_img.show()\n    cut_img.save(panorama_path.replace(\".png\", \"\") + \"_cut.png\")\n\n    logger.warning(\"Saved cut to media/*_cut.png\")\n</code></pre>"},{"location":"rift_console/#rift_console.image_processing.stitch_images","title":"<code>stitch_images(image_path, image_name_list, panorama=None)</code>","text":"<p>Main stitching algorithm TODO add existing img</p> <p>Parameters:</p> Name Type Description Default <code>image_path</code> <code>str</code> <p>description</p> required <code>images</code> <code>list[str]</code> <p>description</p> required <p>Returns:</p> Type Description <code>Image</code> <p>Image.Image: description</p> Source code in <code>src/rift_console/image_processing.py</code> <pre><code>def stitch_images(\n    image_path: str, image_name_list: list[str], panorama: Optional[Image.Image] = None\n) -&gt; Image.Image:\n    \"\"\"Main stitching algorithm\n    TODO add existing img\n\n    Args:\n        image_path (str): _description_\n        images (list[str]): _description_\n        panorama\n\n    Returns:\n        Image.Image: _description_\n    \"\"\"\n    # create new panorama if it does not exist\n    if panorama is None:\n        # add 1000 pixels on each side be used by nudging\n        panorama = Image.new(\n            \"RGBA\",\n            (\n                con.WORLD_X + con.STITCHING_BORDER * 2,\n                con.WORLD_Y + con.STITCHING_BORDER * 2,\n            ),\n        )\n\n    processed_images_counter = 0\n    nudging_failed_counter = 0\n    to_few_pixel_counter = 0\n    max_offset_database = []\n\n    # iterate images\n    for image_name in image_name_list:\n        with Image.open(image_path + image_name) as img:\n            # extract image name\n            lens_size, x, y = parse_image_name(image_name)\n            try:\n                img = img.convert(\"RGBA\")\n            except OSError as e:\n                logger.warning(\n                    f\"Could not parse file {image_name}, skipped. Error: {e}\"\n                )\n                continue\n\n            # possible resize\n            if lens_size != 600:\n                img = img.resize((lens_size, lens_size), Image.Resampling.LANCZOS)\n\n            logger.info(f\"Parsing {image_name}\")\n            logger.debug(f\"{img.size} {img.mode}\")\n\n            # try position in a square arround the center\n            # values 7x7 Grid: d = 3, n = 28   9x9 Grid: d = 4 n = 80   11x11 Grid, d = 5 n = 120\n            spiral_coordinates = generate_spiral_walk(\n                con.SEARCH_GRID_SIDE_LENGTH * con.SEARCH_GRID_SIDE_LENGTH\n            )\n\n            max_offset = int((con.SEARCH_GRID_SIDE_LENGTH - 1) / 2)\n            existing_stitch = panorama.crop(\n                (\n                    x - max_offset + con.STITCHING_BORDER,\n                    y - max_offset + con.STITCHING_BORDER,\n                    x + lens_size + max_offset + con.STITCHING_BORDER,\n                    y + lens_size + max_offset + con.STITCHING_BORDER,\n                )\n            )\n\n            # check if existing_stich contains something\n            total_pixel = existing_stitch.size[0] * existing_stitch.size[1]\n            set_pixel = sum(\n                pixel != (0, 0, 0, 0) for pixel in list(existing_stitch.getdata())\n            )\n            empty_pixel = total_pixel - set_pixel\n\n            logger.debug(\n                f\"Existing stich ({existing_stitch.size[0]},{existing_stitch.size[1]}) w. {total_pixel}p \"\n                + f\"set: {set_pixel} {set_pixel/total_pixel}% and transparent: {empty_pixel} {empty_pixel/total_pixel}%\"\n            )\n\n            best_match_count = 0\n            best_offset = (0, 0)\n            skip = False\n\n            # TODO next goal would to move in only one direction in which the matches get better\n            if con.DO_IMAGE_NUDGING_SEARCH:\n                # probiere nur zu match_count falls mehr als 20% aller pixel gef\u00fcllt\n                if set_pixel / total_pixel == 0:\n                    logger.warning(\"Emtpy panoarma, image still placed\")\n\n                elif set_pixel / total_pixel &gt; 0.2:\n                    # make a func with static params for this image\n                    count_part = partial(\n                        count_matching_pixels,\n                        first_img=img,\n                        second_img=existing_stitch,\n                        max_offset=max_offset,\n                    )\n\n                    with ProcessPoolExecutor(\n                        max_workers=con.NUMBER_OF_WORKER_THREADS\n                    ) as executor:\n                        # each Thread gets automatically assign a different coordinate from the pool\n                        results = executor.map(count_part, spiral_coordinates)\n\n                    for offset, matches in results:\n                        if matches &gt; best_match_count:\n                            logger.info(\n                                f\"New best: matches {matches}p ({matches/total_pixel}%), with offset {best_offset}\\n\"\n                            )\n                            best_offset = offset\n                            best_match_count = matches\n\n                    # check if it worked\n                    if best_match_count / (set_pixel) &lt; 0.5:\n                        logger.warning(\n                            f\"Nudging failed, image skipped, since best_match_count: {best_match_count}p ({best_match_count/total_pixel}%)\"\n                        )\n\n                        skip = True\n                        nudging_failed_counter += 1\n\n                        logger.warning(\n                            f\"{max(abs(best_offset[0]), abs(best_offset[1]))} {best_offset[0]} {best_offset[1]}\"\n                        )\n                        max_offset_database.append(\n                            max(abs(best_offset[0]), abs(best_offset[1]))\n                        )\n                else:\n                    logger.warning(\n                        f\"Too few pixel on panorama, image skipped, set_pixel%: {set_pixel/total_pixel}\"\n                    )\n                    skip = True\n                    to_few_pixel_counter += 1\n\n                # need to check math for % here!\n                logger.debug(\n                    f\"Placed Image best_match_count: {best_match_count}p ({best_match_count/total_pixel}%) with offset: {best_offset}\\n\"\n                )\n\n            if not skip:\n                panorama.paste(\n                    img,\n                    (\n                        x + best_offset[0] + con.STITCHING_BORDER,\n                        y + best_offset[1] + con.STITCHING_BORDER,\n                    ),\n                )\n\n            processed_images_counter += 1\n            if processed_images_counter % con.SAVE_PANORAMA_STEP == 0:\n                panorama.save(\n                    con.PANORAMA_PATH + \"step_\" + str(processed_images_counter) + \".png\"\n                )\n\n        # if any(pixel &lt; 255 for pixel in alpha.getdata()):\n        #    return True\n\n        if processed_images_counter &gt;= con.STITCHING_COUNT_LIMIT:\n            logger.warning(\n                f\"STITCHING_COUNT_LIMIT of {con.STITCHING_COUNT_LIMIT} reached!\"\n            )\n            break\n\n    logger.warning(\n        f\"\\n\\nDone stitching of {processed_images_counter} from {len(image_name_list)} given images\"\n    )\n    if con.DO_IMAGE_NUDGING_SEARCH:\n        logger.warning(\n            f\"nudging_failed_counter: {nudging_failed_counter} , to_few_pixel_counter: {to_few_pixel_counter}\\n\"\n        )\n\n    for element, count in Counter(max_offset_database).items():\n        logger.warning(f\"Max_offset up to {element} occured {count} times\")\n\n    return panorama\n</code></pre>"},{"location":"rift_console/#rift_console.image_processing.upload","title":"<code>upload(id, path, folder=False)</code>","text":"<p>Uploads one objective image\"</p> Source code in <code>src/rift_console/image_processing.py</code> <pre><code>def upload(id: int, path: str, folder: bool = False) -&gt; None:\n    \"\"\"Uploads one objective image\" \"\"\"\n\n    if folder:\n        images = find_image_names(path)\n        for img in images:\n            logger.warning(img)\n            upload(id, path + \"/\" + img, False)\n\n            logger.warning(f\"Uploaded folder of {len(images)}.\")\n        return\n\n    logger.info(f\"Uploading {id} with path {path}\")\n    params = {\"objective_id\": id}\n\n    files = {\"image\": (path, open(path, \"rb\"), \"image/png\")}\n\n    with requests.Session() as s:\n        r = s.post(con.IMAGE_ENDPOINT, params=params, files=files)\n\n        if r.status_code == 200:\n            logger.warning(f\"Uploaded: {r}\")\n            logger.warning(f\"{r.text}{r.json()}\")\n        else:\n            logger.error(f\"Upload failed with code: {r.status_code}\")\n            logger.error(f\"{r.text} {r.json()}\")\n    logger.info(\"Done with Uplaod!\")\n</code></pre>"},{"location":"rift_console/#rift_console.melvin_api","title":"<code>melvin_api</code>","text":""},{"location":"rift_console/#rift_console.melvin_api.port","title":"<code>port = '8080'</code>  <code>module-attribute</code>","text":""},{"location":"rift_console/#rift_console.melvin_api.url","title":"<code>url = 'localhost'</code>  <code>module-attribute</code>","text":""},{"location":"rift_console/#rift_console.melvin_api.MelvonautTelemetry","title":"<code>MelvonautTelemetry</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Datapoint of Disk, Memory and CPU utilization.</p> Source code in <code>src/rift_console/melvin_api.py</code> <pre><code>class MelvonautTelemetry(BaseModel):\n    \"\"\"Datapoint of Disk, Memory and CPU utilization.\"\"\"\n    disk_total: int\n    disk_free: int\n    disk_perc: float\n    mem_total: int\n    mem_available: int\n    mem_perc: float\n    cpu_cores: int\n    cpu_perc: float\n</code></pre>"},{"location":"rift_console/#rift_console.melvin_api.MelvonautTelemetry.cpu_cores","title":"<code>cpu_cores</code>  <code>instance-attribute</code>","text":""},{"location":"rift_console/#rift_console.melvin_api.MelvonautTelemetry.cpu_perc","title":"<code>cpu_perc</code>  <code>instance-attribute</code>","text":""},{"location":"rift_console/#rift_console.melvin_api.MelvonautTelemetry.disk_free","title":"<code>disk_free</code>  <code>instance-attribute</code>","text":""},{"location":"rift_console/#rift_console.melvin_api.MelvonautTelemetry.disk_perc","title":"<code>disk_perc</code>  <code>instance-attribute</code>","text":""},{"location":"rift_console/#rift_console.melvin_api.MelvonautTelemetry.disk_total","title":"<code>disk_total</code>  <code>instance-attribute</code>","text":""},{"location":"rift_console/#rift_console.melvin_api.MelvonautTelemetry.mem_available","title":"<code>mem_available</code>  <code>instance-attribute</code>","text":""},{"location":"rift_console/#rift_console.melvin_api.MelvonautTelemetry.mem_perc","title":"<code>mem_perc</code>  <code>instance-attribute</code>","text":""},{"location":"rift_console/#rift_console.melvin_api.MelvonautTelemetry.mem_total","title":"<code>mem_total</code>  <code>instance-attribute</code>","text":""},{"location":"rift_console/#rift_console.melvin_api.clear_events","title":"<code>clear_events()</code>","text":"<p>Clear event log.</p> Source code in <code>src/rift_console/melvin_api.py</code> <pre><code>def clear_events() -&gt; str:\n    \"\"\"Clear event log.\"\"\"\n    if not melvonaut_api(method=HttpCode.GET, endpoint=\"/api/health\"):\n        logger.warning(\"Melvonaut API unreachable!\")\n        return \"\"\n\n    r = melvonaut_api(method=HttpCode.GET, endpoint=\"/api/get_clear_events\")\n\n    if r:\n        res = \"Mevlonaut get_clear_events done.\"\n    else:\n        res = \"Mevlonaut get_clear_events failed, is okay if event-log is empty.\"\n    logger.warning(res)\n    return res\n</code></pre>"},{"location":"rift_console/#rift_console.melvin_api.clear_images","title":"<code>clear_images()</code>","text":"<p>Deletes exisiting images on Melvonaut.</p> Source code in <code>src/rift_console/melvin_api.py</code> <pre><code>def clear_images() -&gt; bool:\n    \"\"\"Deletes exisiting images on Melvonaut.\"\"\"\n    if not melvonaut_api(method=HttpCode.GET, endpoint=\"/api/health\"):\n        logger.warning(\"Melvonaut API unreachable!\")\n        return False\n\n    r = melvonaut_api(method=HttpCode.GET, endpoint=\"/api/get_clear_all_images\")\n\n    if r:\n        logger.warning(\"Mevlonaut cleared all images done.\")\n        return True\n    else:\n        logger.warning(\"Mevlonaut clear_images failed.\")\n        return False\n</code></pre>"},{"location":"rift_console/#rift_console.melvin_api.clear_logs","title":"<code>clear_logs()</code>","text":"<p>Deletes logs on Melvonaut.</p> Source code in <code>src/rift_console/melvin_api.py</code> <pre><code>def clear_logs() -&gt; bool:\n    \"\"\"Deletes logs on Melvonaut.\"\"\"\n    if not melvonaut_api(method=HttpCode.GET, endpoint=\"/api/health\"):\n        logger.warning(\"Melvonaut API unreachable!\")\n        return False\n\n    r = melvonaut_api(method=HttpCode.GET, endpoint=\"/api/get_clear_all_logs\")\n\n    if r:\n        logger.warning(\"Mevlonaut cleared all logs done.\")\n        return True\n    else:\n        logger.warning(\"Mevlonaut clear_logs failed.\")\n        return False\n</code></pre>"},{"location":"rift_console/#rift_console.melvin_api.clear_telemetry","title":"<code>clear_telemetry()</code>","text":"<p>Delete exisiting telemtry files on Melvonaut.</p> Source code in <code>src/rift_console/melvin_api.py</code> <pre><code>def clear_telemetry() -&gt; str:\n    \"\"\"Delete exisiting telemtry files on Melvonaut.\"\"\"\n    if not melvonaut_api(method=HttpCode.GET, endpoint=\"/api/health\"):\n        logger.warning(\"Melvonaut API unreachable!\")\n        return \"\"\n\n    r = melvonaut_api(method=HttpCode.GET, endpoint=\"/api/get_clear_telemetry\")\n\n    if r:\n        res = \"Mevlonaut clear_telemetry done.\"\n    else:\n        res = \"Mevlonaut clear_telemetry failed.\"\n\n    logger.warning(res)\n    return res\n</code></pre>"},{"location":"rift_console/#rift_console.melvin_api.create_tunnel","title":"<code>create_tunnel()</code>","text":"<p>Not completed function to automatically create an ssh tunnel with port forwarding, alternative use 'shpass -f .ssh-pw ssh -N -L 8080:localhost:8080 root@10.100.50.1'</p> Source code in <code>src/rift_console/melvin_api.py</code> <pre><code>def create_tunnel() -&gt; None:\n    \"\"\"Not completed function to automatically create an ssh tunnel with port forwarding,\n    alternative use 'shpass -f .ssh-pw ssh -N -L 8080:localhost:8080 root@10.100.50.1'\"\"\"\n    cmd = [\n        \"sshpass\",\n        \"-f\",\n        \".ssh-pw\",\n        \"ssh\",\n        \"root@10.100.50.1\",\n        \"-N\",\n        \"-L\",\n        \"8080:localhost:8080\",\n        \"-o\",\n        \"ConnectTimeout=1s\",\n    ]\n    timeout = 60 * 15  # kill connection after 15 min\n\n    process = subprocess.Popen(args=cmd)\n    logger.info(f\"Started tunnel: {process.pid}\")\n\n    # Function to terminate the process\n    def terminate_process() -&gt; None:\n        logger.warning(\"Cleanup tunnel\")\n        os.killpg(os.getpgid(process.pid), signal.SIGTERM)\n\n    # Start a timer to terminate the process after timeout\n    timer = threading.Timer(timeout, terminate_process)\n    timer.start()\n\n    return\n</code></pre>"},{"location":"rift_console/#rift_console.melvin_api.download_events","title":"<code>download_events()</code>","text":"<p>Download event log.</p> Source code in <code>src/rift_console/melvin_api.py</code> <pre><code>def download_events() -&gt; str:\n    \"\"\"Download event log.\"\"\"\n    if not melvonaut_api(method=HttpCode.GET, endpoint=\"/api/health\"):\n        logger.warning(\"Melvonaut API unreachable!\")\n        return \"\"\n\n    r = melvonaut_api(method=HttpCode.GET, endpoint=\"/api/get_download_events\")\n    if r:\n        decoded_content = r.content.decode(\"utf-8\")\n        csv_file_path = (\n            con.CONSOLE_FROM_MELVONAUT_PATH\n            + \"MelvonautEvents-\"\n            + live_utc().strftime(\"%Y-%m-%dT%H:%M:%S\")\n            + \".csv\"\n        )\n\n        with open(csv_file_path, \"w\", newline=\"\", encoding=\"utf-8\") as file:\n            file.write(decoded_content)\n        with open(csv_file_path, mode=\"r\", newline=\"\", encoding=\"utf-8\") as file:\n            csv_reader = csv.reader(file)\n            line_count = sum(1 for _ in csv_reader)\n\n        res = f\"Mevlonaut get_download_events to {csv_file_path} with {line_count} lines done.\"\n    else:\n        res = \"Mevlonaut get_download_events failed, is okay if event-log is empty.\"\n    logger.warning(res)\n    return res\n</code></pre>"},{"location":"rift_console/#rift_console.melvin_api.download_telemetry","title":"<code>download_telemetry()</code>","text":"<p>Download existing telemetry files on Melvonaut.</p> Source code in <code>src/rift_console/melvin_api.py</code> <pre><code>def download_telemetry() -&gt; str:\n    \"\"\"Download existing telemetry files on Melvonaut.\"\"\"\n    if not melvonaut_api(method=HttpCode.GET, endpoint=\"/api/health\"):\n        logger.warning(\"Melvonaut API unreachable!\")\n        return \"\"\n\n    r = melvonaut_api(method=HttpCode.GET, endpoint=\"/api/get_download_telemetry\")\n    if r:\n        decoded_content = r.content.decode(\"utf-8\")\n        csv_file_path = (\n            con.CONSOLE_FROM_MELVONAUT_PATH\n            + \"MelvonautTelemetry-\"\n            + live_utc().strftime(\"%Y-%m-%dT%H:%M:%S\")\n            + \".csv\"\n        )\n\n        with open(csv_file_path, \"w\", newline=\"\", encoding=\"utf-8\") as file:\n            file.write(decoded_content)\n        with open(csv_file_path, mode=\"r\", newline=\"\", encoding=\"utf-8\") as file:\n            csv_reader = csv.reader(file)\n            line_count = sum(1 for _ in csv_reader)\n\n        res = f\"Mevlonaut download_telemetry to {csv_file_path} with {line_count} lines done.\"\n    else:\n        res = \"Mevlonaut download_telemetry failed.\"\n    logger.warning(res)\n    return res\n</code></pre>"},{"location":"rift_console/#rift_console.melvin_api.get_download_save_image","title":"<code>get_download_save_image(image_name)</code>","text":"<p>Download a single image from Melvonaut.</p> Source code in <code>src/rift_console/melvin_api.py</code> <pre><code>def get_download_save_image(image_name: str) -&gt; Any:\n    \"\"\"Download a single image from Melvonaut.\"\"\"\n    if not melvonaut_api(method=HttpCode.GET, endpoint=\"/api/health\"):\n        logger.warning(\"Melvonaut API unreachable!\")\n        return None\n\n    r = melvonaut_api(\n        method=HttpCode.POST,\n        endpoint=\"/api/post_download_image\",\n        json={\"file\": image_name},\n    )\n\n    if r:\n        logger.info(f'Mevlonaut downloaded \"{image_name}\" done.')\n        return r\n    else:\n        logger.warning(\"Mevlonaut get_download_save_image failed.\")\n        return None\n</code></pre>"},{"location":"rift_console/#rift_console.melvin_api.get_download_save_log","title":"<code>get_download_save_log(log_name)</code>","text":"<p>Downloads all logs from Melvonaut.</p> Source code in <code>src/rift_console/melvin_api.py</code> <pre><code>def get_download_save_log(log_name: str) -&gt; Any:\n    \"\"\"Downloads all logs from Melvonaut.\"\"\"\n    if not melvonaut_api(method=HttpCode.GET, endpoint=\"/api/health\"):\n        logger.warning(\"Melvonaut API unreachable!\")\n        return None\n\n    r = melvonaut_api(\n        method=HttpCode.POST, endpoint=\"/api/post_download_log\", json={\"file\": log_name}\n    )\n\n    if r:\n        logger.info(f'Mevlonaut downloaded \"{log_name}\" done.')\n        return r\n    else:\n        logger.warning(\"Mevlonaut get_download_save_log failed.\")\n        return None\n</code></pre>"},{"location":"rift_console/#rift_console.melvin_api.get_setting","title":"<code>get_setting(setting)</code>","text":"<p>Get a Melvonaut Setting from settings.py.</p> Source code in <code>src/rift_console/melvin_api.py</code> <pre><code>def get_setting(setting: str) -&gt; str:\n    \"\"\"Get a Melvonaut Setting from settings.py.\"\"\"\n    if not melvonaut_api(method=HttpCode.GET, endpoint=\"/api/health\"):\n        logger.warning(\"Melvonaut API unreachable!\")\n        return \"\"\n    check = melvonaut_api(\n        method=HttpCode.POST, endpoint=\"/api/post_get_setting\", json={setting: \"\"}\n    )\n\n    if check:\n        value = str(check.json()[setting])\n        logger.info(f'Mevlonaut get settting \"{setting}\" is \"{value}\" done.')\n        return value\n    logger.warning('Mevlonaut get setting \"{setting}\" failed.')\n    return \"\"\n</code></pre>"},{"location":"rift_console/#rift_console.melvin_api.list_images","title":"<code>list_images()</code>","text":"<p>List all exising images on Melvonaut.</p> Source code in <code>src/rift_console/melvin_api.py</code> <pre><code>def list_images() -&gt; list[str] | bool:\n    \"\"\"List all exising images on Melvonaut.\"\"\"\n    if not melvonaut_api(method=HttpCode.GET, endpoint=\"/api/health\"):\n        logger.warning(\"Melvonaut API unreachable!\")\n        return False\n\n    r = melvonaut_api(method=HttpCode.GET, endpoint=\"/api/get_list_images\").json()\n\n    if r:\n        images: list[str] = r[\"images\"]\n        logger.info(f\"Mevlonaut image list done, found {len(images)} images.\")\n        return images\n    else:\n        logger.warning(\"Mevlonaut list_images failed.\")\n        return False\n</code></pre>"},{"location":"rift_console/#rift_console.melvin_api.list_logs","title":"<code>list_logs()</code>","text":"<p>List all log fiels on Melvonaut.</p> Source code in <code>src/rift_console/melvin_api.py</code> <pre><code>def list_logs() -&gt; list[str] | bool:\n    \"\"\"List all log fiels on Melvonaut.\"\"\"\n    if not melvonaut_api(method=HttpCode.GET, endpoint=\"/api/health\"):\n        logger.warning(\"Melvonaut API unreachable!\")\n        return False\n\n    r = melvonaut_api(method=HttpCode.GET, endpoint=\"/api/get_list_log_files\").json()\n\n    if r:\n        logs: list[str] = r[\"log_files\"]\n        logger.info(f\"Mevlonaut list logs done, found {len(logs)} images.\")\n        return logs\n    else:\n        logger.warning(\"Mevlonaut list_images failed.\")\n        return False\n</code></pre>"},{"location":"rift_console/#rift_console.melvin_api.live_melvonaut","title":"<code>live_melvonaut()</code>","text":"<p>Get live MelvonautTelemetry.</p> Source code in <code>src/rift_console/melvin_api.py</code> <pre><code>def live_melvonaut() -&gt; Optional[MelvonautTelemetry]:\n    \"\"\"Get live MelvonautTelemetry.\"\"\"\n    if not melvonaut_api(method=HttpCode.GET, endpoint=\"/api/health\"):\n        logger.warning(\"Melvonaut API unreachable!\")\n        return None\n    d = melvonaut_api(method=HttpCode.GET, endpoint=\"/api/get_disk_usage\").json()\n    m = melvonaut_api(method=HttpCode.GET, endpoint=\"/api/get_memory_usage\").json()\n    c = melvonaut_api(method=HttpCode.GET, endpoint=\"/api/get_cpu_usage\").json()\n\n    gigabyte = 2**30\n    if d and m and c:\n        logger.info(\"Mevlonaut telemetry done.\")\n        return MelvonautTelemetry(\n            disk_total=int(d[\"root\"][\"total\"] / gigabyte),\n            disk_free=int(d[\"root\"][\"free\"] / gigabyte),\n            disk_perc=100 - d[\"root\"][\"percent\"],  # invert\n            mem_total=int(m[\"total\"] / gigabyte),\n            mem_available=int(m[\"available\"] / gigabyte),\n            mem_perc=m[\"percent\"],\n            cpu_cores=c[\"physical_cores\"],\n            cpu_perc=c[\"percent\"],\n        )\n    else:\n        logger.warning(\"Mevlonaut telemetry failed.\")\n        return None\n</code></pre>"},{"location":"rift_console/#rift_console.melvin_api.melvonaut_api","title":"<code>melvonaut_api(method, endpoint, json={})</code>","text":"<p>Wrapper with error handling for Melvonaut API.</p> Source code in <code>src/rift_console/melvin_api.py</code> <pre><code>def melvonaut_api(method: HttpCode, endpoint: str, json: dict[str, str] = {}) -&gt; Any:\n    \"\"\"Wrapper with error handling for Melvonaut API.\"\"\"\n    try:\n        with requests.Session() as s:\n            match method:\n                case HttpCode.GET:\n                    r = s.get(\"http://\" + url + \":\" + port + endpoint, timeout=5)\n                case HttpCode.POST:\n                    r = s.post(\n                        \"http://\" + url + \":\" + port + endpoint,\n                        timeout=5,\n                        json=json,\n                    )\n\n    except requests.exceptions.ConnectionError:\n        logger.error(\"ConnectionError - possible no VPN?\")\n        return {}\n    except requests.exceptions.ReadTimeout:\n        logger.error(\"Timeout error!\")\n        return {}\n\n    match r.status_code:\n        case 200:\n            try:\n                logger.debug(\n                    f\"Received from API {method}/{endpoint} - {r} - {r.json()}\"\n                )\n            except requests.exceptions.JSONDecodeError:\n                logger.debug(f\"Received from API {method}/{endpoint} - {r}\")\n            return r\n        case 404:\n            logger.warning(f\"Requested ressource not found - {r}.\")\n            return {}\n        case _:\n            # unknow error\n            logger.warning(f\"Unknown error, could not contact satellite? - {r}.\")\n            return {}\n</code></pre>"},{"location":"rift_console/#rift_console.melvin_api.set_setting","title":"<code>set_setting(setting, value)</code>","text":"<p>Set a Melvonaut Setting from settings.py.</p> Source code in <code>src/rift_console/melvin_api.py</code> <pre><code>def set_setting(setting: str, value: str) -&gt; bool:\n    \"\"\"Set a Melvonaut Setting from settings.py.\"\"\"\n    if not melvonaut_api(method=HttpCode.GET, endpoint=\"/api/health\"):\n        logger.warning(\"Melvonaut API unreachable!\")\n        return False\n    r = melvonaut_api(\n        method=HttpCode.POST, endpoint=\"/api/post_set_setting\", json={setting: value}\n    )\n\n    if r:\n        check = melvonaut_api(\n            method=HttpCode.POST, endpoint=\"/api/post_get_setting\", json={setting: \"\"}\n        )\n        logger.error(f\"{check.json()} {value}\")\n        if check.json()[setting] == value:\n            logger.info(f'Mevlonaut set_Settting \"{setting}\" to \"{value}\" done.')\n            return True\n    logger.warning(f'Mevlonaut set_Settting \"{setting}\" to \"{value}\" failed.')\n    return False\n</code></pre>"},{"location":"rift_console/#rift_console.rift_console","title":"<code>rift_console</code>","text":""},{"location":"rift_console/#rift_console.rift_console.RiftConsole","title":"<code>RiftConsole</code>","text":"<p>State of a currently running Console, including live data from CIARC/Melvonaut API.</p> Source code in <code>src/rift_console/rift_console.py</code> <pre><code>class RiftConsole:\n    \"\"\"State of a currently running Console, including live data from CIARC/Melvonaut API.\"\"\"\n\n    last_backup_date: Optional[datetime.datetime] = None\n    is_network_simulation: Optional[bool] = None\n    user_speed_multiplier: Optional[int] = None\n\n    live_telemetry: Optional[BaseTelemetry] = None\n    prev_state: State = State.Unknown\n    next_state: State = State.Unknown\n    slots_used: Optional[int] = None\n    slots: list[Slot] = []\n    zoned_objectives: list[ZonedObjective] = []\n    beacon_objectives: list[BeaconObjective] = []\n    completed_ids: list[int] = []\n    achievements: list[Achievement] = []\n    past_traj: list[tuple[int, int]] = []\n    future_traj: list[tuple[int, int]] = []\n    live_melvonaut_api: Optional[MelvonautTelemetry] = None\n    melvonaut_image_count: int = -1  # -1 indicates no data\n    console_image_count: int = -1  # -1 indicates no data\n    console_image_dates: list[tuple[str, int]] = []\n    ebt_ping_list: list[tuple[int, int]] = []\n    console_found_events: list[Event] = []\n    melvin_task: str = \"\"\n    melvin_lens: str = \"\"\n\n    def get_draw_zoned_obj(self) -&gt; list[dict[str, object]]:\n        \"\"\"Picks objectives to be drawn later from its telemetry.\"\"\"\n        get_draw_zoned_obj = []\n        for obj in self.zoned_objectives:\n            if obj.zone is not None:\n                draw = {\n                    \"name\": obj.id,\n                    \"zone\": [\n                        int(obj.zone[0]),\n                        int(obj.zone[1]),\n                        int(obj.zone[2]),\n                        int(obj.zone[3]),\n                    ],\n                }\n                get_draw_zoned_obj.append(draw)\n                if len(get_draw_zoned_obj) &gt;= 5:  # only collect 5 for visual clarity\n                    break\n        return get_draw_zoned_obj\n\n    def predict_trajektorie(\n        self,\n    ) -&gt; tuple[list[tuple[int, int]], list[tuple[int, int]]]:\n        \"\"\"Calculate the points that melvin goes through next\"\"\"\n        past = []\n        future = []\n\n        if self.live_telemetry:\n            for i in range(0, con.TRAJ_TIME, con.TRAJ_STEP):\n                (x, y) = RiftConsole.fix_overflow(\n                    int(self.live_telemetry.width_x + self.live_telemetry.vx * i),\n                    int(self.live_telemetry.height_y + self.live_telemetry.vy * i),\n                )\n                future.append((x, y))\n                (x, y) = RiftConsole.fix_overflow(\n                    int(self.live_telemetry.width_x - self.live_telemetry.vx * i),\n                    int(self.live_telemetry.height_y - self.live_telemetry.vy * i),\n                )\n                past.append((x, y))\n\n        return (past, future)\n\n    @staticmethod\n    def fix_overflow(x: int, y: int) -&gt; tuple[int, int]:\n        \"\"\"Helper for trajektorie predition. Does \"teleportation\" when MELVIN reaches one side of the map.\"\"\"\n        if x &gt; con.WORLD_X:\n            x = x % con.WORLD_X\n\n        while x &lt; 0:\n            x += con.WORLD_X\n\n        if y &gt; con.WORLD_Y:\n            y = y % con.WORLD_Y\n        while y &lt; 0:\n            y += con.WORLD_Y\n\n        return (x, y)\n</code></pre>"},{"location":"rift_console/#rift_console.rift_console.RiftConsole.achievements","title":"<code>achievements = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"rift_console/#rift_console.rift_console.RiftConsole.beacon_objectives","title":"<code>beacon_objectives = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"rift_console/#rift_console.rift_console.RiftConsole.completed_ids","title":"<code>completed_ids = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"rift_console/#rift_console.rift_console.RiftConsole.console_found_events","title":"<code>console_found_events = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"rift_console/#rift_console.rift_console.RiftConsole.console_image_count","title":"<code>console_image_count = -1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"rift_console/#rift_console.rift_console.RiftConsole.console_image_dates","title":"<code>console_image_dates = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"rift_console/#rift_console.rift_console.RiftConsole.ebt_ping_list","title":"<code>ebt_ping_list = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"rift_console/#rift_console.rift_console.RiftConsole.future_traj","title":"<code>future_traj = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"rift_console/#rift_console.rift_console.RiftConsole.is_network_simulation","title":"<code>is_network_simulation = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"rift_console/#rift_console.rift_console.RiftConsole.last_backup_date","title":"<code>last_backup_date = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"rift_console/#rift_console.rift_console.RiftConsole.live_melvonaut_api","title":"<code>live_melvonaut_api = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"rift_console/#rift_console.rift_console.RiftConsole.live_telemetry","title":"<code>live_telemetry = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"rift_console/#rift_console.rift_console.RiftConsole.melvin_lens","title":"<code>melvin_lens = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"rift_console/#rift_console.rift_console.RiftConsole.melvin_task","title":"<code>melvin_task = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"rift_console/#rift_console.rift_console.RiftConsole.melvonaut_image_count","title":"<code>melvonaut_image_count = -1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"rift_console/#rift_console.rift_console.RiftConsole.next_state","title":"<code>next_state = State.Unknown</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"rift_console/#rift_console.rift_console.RiftConsole.past_traj","title":"<code>past_traj = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"rift_console/#rift_console.rift_console.RiftConsole.prev_state","title":"<code>prev_state = State.Unknown</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"rift_console/#rift_console.rift_console.RiftConsole.slots","title":"<code>slots = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"rift_console/#rift_console.rift_console.RiftConsole.slots_used","title":"<code>slots_used = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"rift_console/#rift_console.rift_console.RiftConsole.user_speed_multiplier","title":"<code>user_speed_multiplier = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"rift_console/#rift_console.rift_console.RiftConsole.zoned_objectives","title":"<code>zoned_objectives = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"rift_console/#rift_console.rift_console.RiftConsole.fix_overflow","title":"<code>fix_overflow(x, y)</code>  <code>staticmethod</code>","text":"<p>Helper for trajektorie predition. Does \"teleportation\" when MELVIN reaches one side of the map.</p> Source code in <code>src/rift_console/rift_console.py</code> <pre><code>@staticmethod\ndef fix_overflow(x: int, y: int) -&gt; tuple[int, int]:\n    \"\"\"Helper for trajektorie predition. Does \"teleportation\" when MELVIN reaches one side of the map.\"\"\"\n    if x &gt; con.WORLD_X:\n        x = x % con.WORLD_X\n\n    while x &lt; 0:\n        x += con.WORLD_X\n\n    if y &gt; con.WORLD_Y:\n        y = y % con.WORLD_Y\n    while y &lt; 0:\n        y += con.WORLD_Y\n\n    return (x, y)\n</code></pre>"},{"location":"rift_console/#rift_console.rift_console.RiftConsole.get_draw_zoned_obj","title":"<code>get_draw_zoned_obj()</code>","text":"<p>Picks objectives to be drawn later from its telemetry.</p> Source code in <code>src/rift_console/rift_console.py</code> <pre><code>def get_draw_zoned_obj(self) -&gt; list[dict[str, object]]:\n    \"\"\"Picks objectives to be drawn later from its telemetry.\"\"\"\n    get_draw_zoned_obj = []\n    for obj in self.zoned_objectives:\n        if obj.zone is not None:\n            draw = {\n                \"name\": obj.id,\n                \"zone\": [\n                    int(obj.zone[0]),\n                    int(obj.zone[1]),\n                    int(obj.zone[2]),\n                    int(obj.zone[3]),\n                ],\n            }\n            get_draw_zoned_obj.append(draw)\n            if len(get_draw_zoned_obj) &gt;= 5:  # only collect 5 for visual clarity\n                break\n    return get_draw_zoned_obj\n</code></pre>"},{"location":"rift_console/#rift_console.rift_console.RiftConsole.predict_trajektorie","title":"<code>predict_trajektorie()</code>","text":"<p>Calculate the points that melvin goes through next</p> Source code in <code>src/rift_console/rift_console.py</code> <pre><code>def predict_trajektorie(\n    self,\n) -&gt; tuple[list[tuple[int, int]], list[tuple[int, int]]]:\n    \"\"\"Calculate the points that melvin goes through next\"\"\"\n    past = []\n    future = []\n\n    if self.live_telemetry:\n        for i in range(0, con.TRAJ_TIME, con.TRAJ_STEP):\n            (x, y) = RiftConsole.fix_overflow(\n                int(self.live_telemetry.width_x + self.live_telemetry.vx * i),\n                int(self.live_telemetry.height_y + self.live_telemetry.vy * i),\n            )\n            future.append((x, y))\n            (x, y) = RiftConsole.fix_overflow(\n                int(self.live_telemetry.width_x - self.live_telemetry.vx * i),\n                int(self.live_telemetry.height_y - self.live_telemetry.vy * i),\n            )\n            past.append((x, y))\n\n    return (past, future)\n</code></pre>"},{"location":"shared/","title":"Shared Reference","text":"<p>Ciarc.</p>"},{"location":"shared/#shared.constants","title":"<code>constants</code>","text":""},{"location":"shared/#shared.constants.ACCELERATION","title":"<code>ACCELERATION = 0.02</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.ACHIEVEMENTS_ENDPOINT","title":"<code>ACHIEVEMENTS_ENDPOINT = f'{BASE_URL}achievements'</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.ANNOUNCEMENTS_ENDPOINT","title":"<code>ANNOUNCEMENTS_ENDPOINT = f'{BASE_URL}announcements'</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.BACKUP_ENDPOINT","title":"<code>BACKUP_ENDPOINT = f'{BASE_URL}backup'</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.BASE_URL","title":"<code>BASE_URL = 'http://10.100.10.11:33000/'</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.BEACON_ENDPOINT","title":"<code>BEACON_ENDPOINT = f'{BASE_URL}beacon'</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.CONSOLE_DOWNLOAD_PATH","title":"<code>CONSOLE_DOWNLOAD_PATH = 'logs/rift_console/images/download/'</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.CONSOLE_EBT_PATH","title":"<code>CONSOLE_EBT_PATH = 'logs/rift_console/images/ebt/'</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.CONSOLE_FROM_MELVONAUT_PATH","title":"<code>CONSOLE_FROM_MELVONAUT_PATH = 'logs/rift_console/from_melvonaut/'</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.CONSOLE_IMAGE_VIEWER_LIMIT","title":"<code>CONSOLE_IMAGE_VIEWER_LIMIT = 1000</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.CONSOLE_LIVE_PATH","title":"<code>CONSOLE_LIVE_PATH = 'logs/rift_console/images/live/'</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.CONSOLE_LOG_PATH","title":"<code>CONSOLE_LOG_PATH = 'logs/rift_console/'</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.CONSOLE_STICHED_PATH","title":"<code>CONSOLE_STICHED_PATH = 'logs/rift_console/images/stitched/'</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.CONTROL_ENDPOINT","title":"<code>CONTROL_ENDPOINT = f'{BASE_URL}control'</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.DAILYMAP_ENDPOINT","title":"<code>DAILYMAP_ENDPOINT = f'{BASE_URL}dailyMap'</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.DO_IMAGE_NUDGING_SEARCH","title":"<code>DO_IMAGE_NUDGING_SEARCH = False</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.EVENT_LOCATION_CSV","title":"<code>EVENT_LOCATION_CSV = 'logs/melvonaut/event_melvonaut.csv'</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.IMAGE_ANGLE_POSITION","title":"<code>IMAGE_ANGLE_POSITION = 2</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.IMAGE_ENDPOINT","title":"<code>IMAGE_ENDPOINT = f'{BASE_URL}image'</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.IMAGE_LOCATION","title":"<code>IMAGE_LOCATION = IMAGE_PATH + 'image_{melv_id}_{angle}_{time}_x_{cor_x}_y_{cor_y}.png'</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.IMAGE_NAME_UNDERSCORE_COUNT","title":"<code>IMAGE_NAME_UNDERSCORE_COUNT = 8</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.IMAGE_NOISE_FORGIVENESS","title":"<code>IMAGE_NOISE_FORGIVENESS = 20</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.IMAGE_PATH","title":"<code>IMAGE_PATH = 'logs/melvonaut/images/'</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.IMAGE_PATH_BASE","title":"<code>IMAGE_PATH_BASE = 'logs/melvonaut/images/'</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.MEL_LOG_FORMAT","title":"<code>MEL_LOG_FORMAT = 'log_melvonaut_{time:YYYY-MM-DD_HH}.log'</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.MEL_LOG_LOCATION","title":"<code>MEL_LOG_LOCATION = MEL_LOG_PATH + MEL_LOG_FORMAT</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.MEL_LOG_PATH","title":"<code>MEL_LOG_PATH = 'logs/melvonaut/'</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.MEL_PERSISTENT_SETTINGS","title":"<code>MEL_PERSISTENT_SETTINGS = 'logs/melvonaut/persistent_settings.json'</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.NUMBER_OF_WORKER_THREADS","title":"<code>NUMBER_OF_WORKER_THREADS = cpu_count() or 4 - 2</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.OBJECTIVE_ENDPOINT","title":"<code>OBJECTIVE_ENDPOINT = f'{BASE_URL}objective'</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.OBSERVATION_ENDPOINT","title":"<code>OBSERVATION_ENDPOINT = f'{BASE_URL}observation'</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.PANORAMA_PATH","title":"<code>PANORAMA_PATH = 'media/'</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.RESET_ENDPOINT","title":"<code>RESET_ENDPOINT = f'{BASE_URL}reset'</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.RIFT_LOG_LEVEL","title":"<code>RIFT_LOG_LEVEL = 'INFO'</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.RIFT_LOG_LOCATION","title":"<code>RIFT_LOG_LOCATION = 'logs/rift_console/log_rift-console_{time:YYYY-MM-DD_HH}.log'</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.SAVE_PANORAMA_STEP","title":"<code>SAVE_PANORAMA_STEP = 1000</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.SEARCH_GRID_SIDE_LENGTH","title":"<code>SEARCH_GRID_SIDE_LENGTH = 15</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.SIMULATION_ENDPOINT","title":"<code>SIMULATION_ENDPOINT = f'{BASE_URL}simulation'</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.SLOTS_ENDPOINT","title":"<code>SLOTS_ENDPOINT = f'{BASE_URL}slots'</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.SORT_IMAGE_BY_POSITION","title":"<code>SORT_IMAGE_BY_POSITION = True</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.STATE_TRANSITION_FROM_SAFE_TIME","title":"<code>STATE_TRANSITION_FROM_SAFE_TIME = 20 * 60</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.STATE_TRANSITION_TIME","title":"<code>STATE_TRANSITION_TIME = 3 * 60</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.STATE_TRANSITION_TO_SAFE_TIME","title":"<code>STATE_TRANSITION_TO_SAFE_TIME = 1 * 60</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.STITCHING_BORDER","title":"<code>STITCHING_BORDER = 1000</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.STITCHING_COUNT_LIMIT","title":"<code>STITCHING_COUNT_LIMIT = 5000</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.TELEMETRY_LOCATION_CSV","title":"<code>TELEMETRY_LOCATION_CSV = 'logs/melvonaut/telemetry_melvonaut.csv'</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.TELEMETRY_LOCATION_JSON","title":"<code>TELEMETRY_LOCATION_JSON = 'logs/melvonaut/telemetry_melvonaut.json'</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.THUMBNAIL_X","title":"<code>THUMBNAIL_X = 1000</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.THUMBNAIL_Y","title":"<code>THUMBNAIL_Y = 500</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.TRAJ_STEP","title":"<code>TRAJ_STEP = 10</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.TRAJ_TIME","title":"<code>TRAJ_TIME = 3600 * 12</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.USE_LEGACY_IMAGE_NAMES","title":"<code>USE_LEGACY_IMAGE_NAMES = False</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.WORLD_X","title":"<code>WORLD_X = 21600</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.constants.WORLD_Y","title":"<code>WORLD_Y = 10800</code>  <code>module-attribute</code>","text":""},{"location":"shared/#shared.models","title":"<code>models</code>","text":""},{"location":"shared/#shared.models.Achievement","title":"<code>Achievement</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>From CIARC API.</p> Source code in <code>src/shared/models.py</code> <pre><code>class Achievement(BaseModel):\n    \"\"\"\n    From CIARC API.\n    \"\"\"\n\n    name: str\n    done: bool\n    points: int\n    description: str\n    goal_parameter_threshold: Union[bool, int, float, str]\n    goal_parameter: Union[bool, int, float, str]\n\n    @staticmethod\n    def parse_api(data: dict) -&gt; list[\"Achievement\"]:  # type: ignore\n        \"\"\"\n        Parse CIARC API into list of Achievment.\n        \"\"\"\n        achv = []\n        for a in data[\"achievements\"]:\n            achv.append(Achievement(**a))\n\n        return achv\n</code></pre>"},{"location":"shared/#shared.models.Achievement.description","title":"<code>description</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.Achievement.done","title":"<code>done</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.Achievement.goal_parameter","title":"<code>goal_parameter</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.Achievement.goal_parameter_threshold","title":"<code>goal_parameter_threshold</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.Achievement.name","title":"<code>name</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.Achievement.points","title":"<code>points</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.Achievement.parse_api","title":"<code>parse_api(data)</code>  <code>staticmethod</code>","text":"<p>Parse CIARC API into list of Achievment.</p> Source code in <code>src/shared/models.py</code> <pre><code>@staticmethod\ndef parse_api(data: dict) -&gt; list[\"Achievement\"]:  # type: ignore\n    \"\"\"\n    Parse CIARC API into list of Achievment.\n    \"\"\"\n    achv = []\n    for a in data[\"achievements\"]:\n        achv.append(Achievement(**a))\n\n    return achv\n</code></pre>"},{"location":"shared/#shared.models.BaseTelemetry","title":"<code>BaseTelemetry</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Based on /observation endpoint.</p> Source code in <code>src/shared/models.py</code> <pre><code>class BaseTelemetry(BaseModel):\n    \"\"\"Based on /observation endpoint.\"\"\"\n\n    model_config = ConfigDict(use_enum_values=True)\n\n    class AreaCovered(BaseModel):\n        narrow: float\n        normal: float\n        wide: float\n\n    class DataVolume(BaseModel):\n        data_volume_received: int\n        data_volume_sent: int\n\n    active_time: float\n    angle: CameraAngle\n    area_covered: AreaCovered\n    battery: float\n    data_volume: DataVolume\n    distance_covered: float\n    fuel: float\n    width_x: int\n    height_y: int\n    images_taken: int\n    max_battery: float\n    objectives_done: int\n    objectives_points: int\n    simulation_speed: int\n    state: State\n    timestamp: datetime.datetime\n    vx: float\n    vy: float\n\n    def __str__(self) -&gt; str:\n        return (\n            f\"Telemetry@{self.timestamp.isoformat()} state={self.state} angle={self.angle} \"\n            f\"(x,y)=({self.width_x},{self.height_y}) (vx,vy)=({self.vx},{self.vy}) \"\n            f\"battery={self.battery}/{self.max_battery} fuel={self.fuel} sim_speed={self.simulation_speed} \"\n            f\"dist_cov={self.distance_covered} area_cov={self.area_covered.narrow}/{self.area_covered.normal}/{self.area_covered.wide} \"\n            f\"active_t={self.active_time} #images={self.images_taken} obj-done/points={self.objectives_done}/{self.objectives_points} \"\n            f\"data-s/r={self.data_volume.data_volume_sent}/{self.data_volume.data_volume_received}\"\n        )\n</code></pre>"},{"location":"shared/#shared.models.BaseTelemetry.active_time","title":"<code>active_time</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.BaseTelemetry.angle","title":"<code>angle</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.BaseTelemetry.area_covered","title":"<code>area_covered</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.BaseTelemetry.battery","title":"<code>battery</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.BaseTelemetry.data_volume","title":"<code>data_volume</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.BaseTelemetry.distance_covered","title":"<code>distance_covered</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.BaseTelemetry.fuel","title":"<code>fuel</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.BaseTelemetry.height_y","title":"<code>height_y</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.BaseTelemetry.images_taken","title":"<code>images_taken</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.BaseTelemetry.max_battery","title":"<code>max_battery</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.BaseTelemetry.model_config","title":"<code>model_config = ConfigDict(use_enum_values=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.BaseTelemetry.objectives_done","title":"<code>objectives_done</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.BaseTelemetry.objectives_points","title":"<code>objectives_points</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.BaseTelemetry.simulation_speed","title":"<code>simulation_speed</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.BaseTelemetry.state","title":"<code>state</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.BaseTelemetry.timestamp","title":"<code>timestamp</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.BaseTelemetry.vx","title":"<code>vx</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.BaseTelemetry.vy","title":"<code>vy</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.BaseTelemetry.width_x","title":"<code>width_x</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.BaseTelemetry.AreaCovered","title":"<code>AreaCovered</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/shared/models.py</code> <pre><code>class AreaCovered(BaseModel):\n    narrow: float\n    normal: float\n    wide: float\n</code></pre>"},{"location":"shared/#shared.models.BaseTelemetry.AreaCovered.narrow","title":"<code>narrow</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.BaseTelemetry.AreaCovered.normal","title":"<code>normal</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.BaseTelemetry.AreaCovered.wide","title":"<code>wide</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.BaseTelemetry.DataVolume","title":"<code>DataVolume</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/shared/models.py</code> <pre><code>class DataVolume(BaseModel):\n    data_volume_received: int\n    data_volume_sent: int\n</code></pre>"},{"location":"shared/#shared.models.BaseTelemetry.DataVolume.data_volume_received","title":"<code>data_volume_received</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.BaseTelemetry.DataVolume.data_volume_sent","title":"<code>data_volume_sent</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.BaseTelemetry.__str__","title":"<code>__str__()</code>","text":"Source code in <code>src/shared/models.py</code> <pre><code>def __str__(self) -&gt; str:\n    return (\n        f\"Telemetry@{self.timestamp.isoformat()} state={self.state} angle={self.angle} \"\n        f\"(x,y)=({self.width_x},{self.height_y}) (vx,vy)=({self.vx},{self.vy}) \"\n        f\"battery={self.battery}/{self.max_battery} fuel={self.fuel} sim_speed={self.simulation_speed} \"\n        f\"dist_cov={self.distance_covered} area_cov={self.area_covered.narrow}/{self.area_covered.normal}/{self.area_covered.wide} \"\n        f\"active_t={self.active_time} #images={self.images_taken} obj-done/points={self.objectives_done}/{self.objectives_points} \"\n        f\"data-s/r={self.data_volume.data_volume_sent}/{self.data_volume.data_volume_received}\"\n    )\n</code></pre>"},{"location":"shared/#shared.models.BeaconObjective","title":"<code>BeaconObjective</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Emergency beacon objective from CIARC API.</p> Source code in <code>src/shared/models.py</code> <pre><code>class BeaconObjective(BaseModel):\n    \"\"\"\n    Emergency beacon objective from CIARC API.\n    \"\"\"\n\n    id: int\n    name: str\n    start: datetime.datetime\n    end: datetime.datetime\n    decrease_rate: float\n    attempts_made: int\n    description: str\n\n    @staticmethod\n    def parse_api(data: dict) -&gt; list[\"BeaconObjective\"]:  # type: ignore\n        \"\"\"\n        Parse CIARC API to list of this class\n        \"\"\"\n        beacon_obj = []\n        for b in data[\"beacon_objectives\"]:\n            beacon_obj.append(BeaconObjective(**b))\n\n        return sorted(beacon_obj, key=lambda event: event.start)\n</code></pre>"},{"location":"shared/#shared.models.BeaconObjective.attempts_made","title":"<code>attempts_made</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.BeaconObjective.decrease_rate","title":"<code>decrease_rate</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.BeaconObjective.description","title":"<code>description</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.BeaconObjective.end","title":"<code>end</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.BeaconObjective.id","title":"<code>id</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.BeaconObjective.name","title":"<code>name</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.BeaconObjective.start","title":"<code>start</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.BeaconObjective.parse_api","title":"<code>parse_api(data)</code>  <code>staticmethod</code>","text":"<p>Parse CIARC API to list of this class</p> Source code in <code>src/shared/models.py</code> <pre><code>@staticmethod\ndef parse_api(data: dict) -&gt; list[\"BeaconObjective\"]:  # type: ignore\n    \"\"\"\n    Parse CIARC API to list of this class\n    \"\"\"\n    beacon_obj = []\n    for b in data[\"beacon_objectives\"]:\n        beacon_obj.append(BeaconObjective(**b))\n\n    return sorted(beacon_obj, key=lambda event: event.start)\n</code></pre>"},{"location":"shared/#shared.models.CameraAngle","title":"<code>CameraAngle</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Different camera angles possible on MELVIN.</p> Source code in <code>src/shared/models.py</code> <pre><code>class CameraAngle(StrEnum):\n    \"\"\"\n    Different camera angles possible on MELVIN.\n    \"\"\"\n\n    Wide = \"wide\"\n    Narrow = \"narrow\"\n    Normal = \"normal\"\n    Unknown = \"unknown\"\n</code></pre>"},{"location":"shared/#shared.models.CameraAngle.Narrow","title":"<code>Narrow = 'narrow'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.CameraAngle.Normal","title":"<code>Normal = 'normal'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.CameraAngle.Unknown","title":"<code>Unknown = 'unknown'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.CameraAngle.Wide","title":"<code>Wide = 'wide'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.Event","title":"<code>Event</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Message by /announcements, includes time and position for ebt processing.</p> Source code in <code>src/shared/models.py</code> <pre><code>class Event(BaseModel):\n    \"\"\"Message by /announcements, includes time and position for ebt processing.\"\"\"\n\n    event: str\n    id: int\n    timestamp: Optional[datetime.datetime] = None\n    current_x: Optional[float] = None\n    current_y: Optional[float] = None\n\n    def __str__(self) -&gt; str:\n        return f\"Event: {self.event} (x,y)=({self.current_x},{self.current_y}) t={time_seconds(self.timestamp or live_utc())}\"\n\n    def easy_parse(self) -&gt; tuple[float, float, float]:\n        \"\"\"Custom parsing wrapper for ebt calculation.\"\"\"\n        pattern = r\"DISTANCE_(\\d+\\.\\d+)\"\n        dist = re.findall(pattern, self.event)[0]\n        if dist and self.current_x and self.current_y:\n            return (float(dist), self.current_x, self.current_y)\n        else:\n            logger.warning(f\"Tried to parse incomplete event: {self}\")\n            return (0.0, 0.0, 0.0)\n\n    async def to_csv(self) -&gt; None:\n        \"\"\"Melvonaut saves events.\"\"\"\n        event_dict = self.model_dump()\n        if self.timestamp:\n            event_dict[\"timestamp\"] = self.timestamp.isoformat()\n        if not Path(con.EVENT_LOCATION_CSV).is_file():\n            async with async_open(con.EVENT_LOCATION_CSV, \"w\") as afp:\n                writer = csv.DictWriter(afp, fieldnames=event_dict.keys())\n                await writer.writeheader()\n                await writer.writerow(event_dict)\n            # logger.debug(f\"Writing event to {con.EVENT_LOCATION_CSV}\")\n        else:\n            async with async_open(con.EVENT_LOCATION_CSV, \"a\") as afp:\n                writer = csv.DictWriter(afp, fieldnames=event_dict.keys())\n                await writer.writerow(event_dict)\n            # logger.debug(f\"Writing event to {con.EVENT_LOCATION_CSV}\")\n\n    @staticmethod\n    def load_events_from_csv(path: str) -&gt; list[\"Event\"]:\n        \"\"\"Melvonaut saves events as csv, Rift-console loads them.\"\"\"\n        events = []\n        if not Path(path).is_file():\n            logger.warning(f\"No event file found under {path}\")\n        else:\n            with open(path, \"r\") as f:\n                for row in csv.DictReader(f):\n                    read_event = Event(\n                        event=row[\"event\"],\n                        id=int(row[\"id\"]),\n                        timestamp=datetime.datetime.fromisoformat(row[\"timestamp\"]),\n                        current_x=float(row[\"current_x\"]),\n                        current_y=float(row[\"current_y\"]),\n                    )\n                    events.append(read_event)\n            logger.info(f\"Loaded {len(events)} events from {path}\")\n        return events\n</code></pre>"},{"location":"shared/#shared.models.Event.current_x","title":"<code>current_x = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.Event.current_y","title":"<code>current_y = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.Event.event","title":"<code>event</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.Event.id","title":"<code>id</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.Event.timestamp","title":"<code>timestamp = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.Event.__str__","title":"<code>__str__()</code>","text":"Source code in <code>src/shared/models.py</code> <pre><code>def __str__(self) -&gt; str:\n    return f\"Event: {self.event} (x,y)=({self.current_x},{self.current_y}) t={time_seconds(self.timestamp or live_utc())}\"\n</code></pre>"},{"location":"shared/#shared.models.Event.easy_parse","title":"<code>easy_parse()</code>","text":"<p>Custom parsing wrapper for ebt calculation.</p> Source code in <code>src/shared/models.py</code> <pre><code>def easy_parse(self) -&gt; tuple[float, float, float]:\n    \"\"\"Custom parsing wrapper for ebt calculation.\"\"\"\n    pattern = r\"DISTANCE_(\\d+\\.\\d+)\"\n    dist = re.findall(pattern, self.event)[0]\n    if dist and self.current_x and self.current_y:\n        return (float(dist), self.current_x, self.current_y)\n    else:\n        logger.warning(f\"Tried to parse incomplete event: {self}\")\n        return (0.0, 0.0, 0.0)\n</code></pre>"},{"location":"shared/#shared.models.Event.load_events_from_csv","title":"<code>load_events_from_csv(path)</code>  <code>staticmethod</code>","text":"<p>Melvonaut saves events as csv, Rift-console loads them.</p> Source code in <code>src/shared/models.py</code> <pre><code>@staticmethod\ndef load_events_from_csv(path: str) -&gt; list[\"Event\"]:\n    \"\"\"Melvonaut saves events as csv, Rift-console loads them.\"\"\"\n    events = []\n    if not Path(path).is_file():\n        logger.warning(f\"No event file found under {path}\")\n    else:\n        with open(path, \"r\") as f:\n            for row in csv.DictReader(f):\n                read_event = Event(\n                    event=row[\"event\"],\n                    id=int(row[\"id\"]),\n                    timestamp=datetime.datetime.fromisoformat(row[\"timestamp\"]),\n                    current_x=float(row[\"current_x\"]),\n                    current_y=float(row[\"current_y\"]),\n                )\n                events.append(read_event)\n        logger.info(f\"Loaded {len(events)} events from {path}\")\n    return events\n</code></pre>"},{"location":"shared/#shared.models.Event.to_csv","title":"<code>to_csv()</code>  <code>async</code>","text":"<p>Melvonaut saves events.</p> Source code in <code>src/shared/models.py</code> <pre><code>async def to_csv(self) -&gt; None:\n    \"\"\"Melvonaut saves events.\"\"\"\n    event_dict = self.model_dump()\n    if self.timestamp:\n        event_dict[\"timestamp\"] = self.timestamp.isoformat()\n    if not Path(con.EVENT_LOCATION_CSV).is_file():\n        async with async_open(con.EVENT_LOCATION_CSV, \"w\") as afp:\n            writer = csv.DictWriter(afp, fieldnames=event_dict.keys())\n            await writer.writeheader()\n            await writer.writerow(event_dict)\n        # logger.debug(f\"Writing event to {con.EVENT_LOCATION_CSV}\")\n    else:\n        async with async_open(con.EVENT_LOCATION_CSV, \"a\") as afp:\n            writer = csv.DictWriter(afp, fieldnames=event_dict.keys())\n            await writer.writerow(event_dict)\n</code></pre>"},{"location":"shared/#shared.models.HttpCode","title":"<code>HttpCode</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Used HTTP codes for API.</p> Source code in <code>src/shared/models.py</code> <pre><code>class HttpCode(Enum):\n    \"\"\"Used HTTP codes for API.\"\"\"\n\n    GET = \"get\"\n    PUT = \"put\"\n    DELETE = \"delete\"\n    POST = \"post\"\n</code></pre>"},{"location":"shared/#shared.models.HttpCode.DELETE","title":"<code>DELETE = 'delete'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.HttpCode.GET","title":"<code>GET = 'get'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.HttpCode.POST","title":"<code>POST = 'post'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.HttpCode.PUT","title":"<code>PUT = 'put'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.MELVINTask","title":"<code>MELVINTask</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Our custom programs/missions/states in which we can place Melvin. In evaluation phase only mapping and ebt was used. The other two were used in Phase 2, or could be used in a future update.</p> Source code in <code>src/shared/models.py</code> <pre><code>class MELVINTask(StrEnum):\n    \"\"\"\n    Our custom programs/missions/states in which we can place Melvin.\n    In evaluation phase only mapping and ebt was used.\n    The other two were used in Phase 2, or could be used in a future update.\n    \"\"\"\n\n    Mapping = \"mapping\"\n    Next_objective = \"next_objective\"\n    Fixed_objective = \"fixed_objective\"\n    EBT = \"ebt\"\n</code></pre>"},{"location":"shared/#shared.models.MELVINTask.EBT","title":"<code>EBT = 'ebt'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.MELVINTask.Fixed_objective","title":"<code>Fixed_objective = 'fixed_objective'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.MELVINTask.Mapping","title":"<code>Mapping = 'mapping'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.MELVINTask.Next_objective","title":"<code>Next_objective = 'next_objective'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.MelvinImage","title":"<code>MelvinImage</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Our format for a single image taken by MELVIN.</p> Source code in <code>src/shared/models.py</code> <pre><code>class MelvinImage(BaseModel):\n    \"\"\"Our format for a single image taken by MELVIN.\"\"\"\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n\n    image: Image.Image\n    angle: CameraAngle\n    cor_x: int\n    cor_y: int\n    time: datetime.datetime\n</code></pre>"},{"location":"shared/#shared.models.MelvinImage.angle","title":"<code>angle</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.MelvinImage.cor_x","title":"<code>cor_x</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.MelvinImage.cor_y","title":"<code>cor_y</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.MelvinImage.image","title":"<code>image</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.MelvinImage.model_config","title":"<code>model_config = ConfigDict(arbitrary_types_allowed=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.MelvinImage.time","title":"<code>time</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.Ping","title":"<code>Ping</code>","text":"<p>Part of EBT objective, one single distance/ping.</p> Source code in <code>src/shared/models.py</code> <pre><code>class Ping:\n    \"\"\"Part of EBT objective, one single distance/ping.\"\"\"\n\n    def __init__(self, x: int, y: int, d: float, mind: int, maxd: int):\n        self.x = x\n        self.y = y\n        self.d = d\n        self.mind = mind\n        self.maxd = maxd\n\n    def __str__(self) -&gt; str:\n        return f\"Ping: x={self.x}, y={self.y}, d={self.d}, mind={self.mind}, maxd={self.maxd}\"\n</code></pre>"},{"location":"shared/#shared.models.Ping.d","title":"<code>d = d</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.Ping.maxd","title":"<code>maxd = maxd</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.Ping.mind","title":"<code>mind = mind</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.Ping.x","title":"<code>x = x</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.Ping.y","title":"<code>y = y</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.Ping.__init__","title":"<code>__init__(x, y, d, mind, maxd)</code>","text":"Source code in <code>src/shared/models.py</code> <pre><code>def __init__(self, x: int, y: int, d: float, mind: int, maxd: int):\n    self.x = x\n    self.y = y\n    self.d = d\n    self.mind = mind\n    self.maxd = maxd\n</code></pre>"},{"location":"shared/#shared.models.Ping.__str__","title":"<code>__str__()</code>","text":"Source code in <code>src/shared/models.py</code> <pre><code>def __str__(self) -&gt; str:\n    return f\"Ping: x={self.x}, y={self.y}, d={self.d}, mind={self.mind}, maxd={self.maxd}\"\n</code></pre>"},{"location":"shared/#shared.models.Slot","title":"<code>Slot</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>One communication slot in which MELVIN can be contacted.</p> <p>Methods:</p> Name Description <code>parse_api</code> <p>dict) -&gt; tuple[int, list[\"Slot\"]]: Parses the given API data to extract slots and the number of slots used.</p> Source code in <code>src/shared/models.py</code> <pre><code>class Slot(BaseModel):\n    \"\"\"\n    One communication slot in which MELVIN can be contacted.\n\n    Methods:\n        parse_api(data: dict) -&gt; tuple[int, list[\"Slot\"]]:\n            Parses the given API data to extract slots and the number of slots used.\n    \"\"\"\n\n    id: int\n    start: datetime.datetime\n    end: datetime.datetime\n    enabled: bool\n\n    @staticmethod\n    def parse_api(data: dict) -&gt; tuple[int, list[\"Slot\"]]:  # type: ignore\n        \"\"\"\n        Parses CIARC API response into the list of available slots.\n\n        Args:\n            data (dict): The API response from /slots.\n\n        Returns:\n            tuple[int, list[\"Slot\"]]: Number of communication slots used and\n                list of slots sorted by the earliest start time.\n\n        \"\"\"\n        slots_used = data[\"communication_slots_used\"]\n        slots = []\n        for s in data[\"slots\"]:\n            slots.append(Slot(**s))\n\n        slots.sort(key=lambda slot: slot.start)\n        # logger.debug(f\"Deparsed Slot API used: {slots_used} - {slots}\")\n        return (slots_used, slots)\n</code></pre>"},{"location":"shared/#shared.models.Slot.enabled","title":"<code>enabled</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.Slot.end","title":"<code>end</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.Slot.id","title":"<code>id</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.Slot.start","title":"<code>start</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.Slot.parse_api","title":"<code>parse_api(data)</code>  <code>staticmethod</code>","text":"<p>Parses CIARC API response into the list of available slots.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>The API response from /slots.</p> required <p>Returns:</p> Type Description <code>tuple[int, list[Slot]]</code> <p>tuple[int, list[\"Slot\"]]: Number of communication slots used and list of slots sorted by the earliest start time.</p> Source code in <code>src/shared/models.py</code> <pre><code>@staticmethod\ndef parse_api(data: dict) -&gt; tuple[int, list[\"Slot\"]]:  # type: ignore\n    \"\"\"\n    Parses CIARC API response into the list of available slots.\n\n    Args:\n        data (dict): The API response from /slots.\n\n    Returns:\n        tuple[int, list[\"Slot\"]]: Number of communication slots used and\n            list of slots sorted by the earliest start time.\n\n    \"\"\"\n    slots_used = data[\"communication_slots_used\"]\n    slots = []\n    for s in data[\"slots\"]:\n        slots.append(Slot(**s))\n\n    slots.sort(key=lambda slot: slot.start)\n    # logger.debug(f\"Deparsed Slot API used: {slots_used} - {slots}\")\n    return (slots_used, slots)\n</code></pre>"},{"location":"shared/#shared.models.State","title":"<code>State</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>From CIARC user manual</p> Source code in <code>src/shared/models.py</code> <pre><code>class State(StrEnum):\n    \"\"\"From CIARC user manual\"\"\"\n\n    Deployment = \"deployment\"\n    Acquisition = \"acquisition\"\n    Charge = \"charge\"\n    Safe = \"safe\"\n    Communication = \"communication\"\n    Transition = \"transition\"\n    Unknown = \"none\"\n</code></pre>"},{"location":"shared/#shared.models.State.Acquisition","title":"<code>Acquisition = 'acquisition'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.State.Charge","title":"<code>Charge = 'charge'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.State.Communication","title":"<code>Communication = 'communication'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.State.Deployment","title":"<code>Deployment = 'deployment'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.State.Safe","title":"<code>Safe = 'safe'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.State.Transition","title":"<code>Transition = 'transition'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.State.Unknown","title":"<code>Unknown = 'none'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.Timer","title":"<code>Timer</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Starts tasks after a given intervall. E.g. take the next picture X-seconds after the current one.</p> Source code in <code>src/shared/models.py</code> <pre><code>class Timer(BaseModel):\n    \"\"\"Starts tasks after a given intervall. E.g. take the next picture X-seconds after the current one.\"\"\"\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n\n    _timeout: float\n    _callback: Callable[[], Awaitable[Any]]\n    _task: asyncio.Task[None]\n\n    def __init__(self, timeout: float, callback: Callable[[], Awaitable[Any]]):\n        super().__init__()\n        self._timeout = timeout\n        self._callback = callback\n        self._task = asyncio.create_task(self._job())\n\n    async def _job(self) -&gt; None:\n        await asyncio.sleep(self._timeout)\n        await self._callback()\n\n    def cancel(self) -&gt; None:\n        self._task.cancel()\n\n    def get_task(self) -&gt; asyncio.Task[None]:\n        return self._task\n</code></pre>"},{"location":"shared/#shared.models.Timer.model_config","title":"<code>model_config = ConfigDict(arbitrary_types_allowed=True)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.Timer.__init__","title":"<code>__init__(timeout, callback)</code>","text":"Source code in <code>src/shared/models.py</code> <pre><code>def __init__(self, timeout: float, callback: Callable[[], Awaitable[Any]]):\n    super().__init__()\n    self._timeout = timeout\n    self._callback = callback\n    self._task = asyncio.create_task(self._job())\n</code></pre>"},{"location":"shared/#shared.models.Timer.cancel","title":"<code>cancel()</code>","text":"Source code in <code>src/shared/models.py</code> <pre><code>def cancel(self) -&gt; None:\n    self._task.cancel()\n</code></pre>"},{"location":"shared/#shared.models.Timer.get_task","title":"<code>get_task()</code>","text":"Source code in <code>src/shared/models.py</code> <pre><code>def get_task(self) -&gt; asyncio.Task[None]:\n    return self._task\n</code></pre>"},{"location":"shared/#shared.models.ZonedObjective","title":"<code>ZonedObjective</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>One hidden or visible objective, completed by taking pictures of its position.</p> Source code in <code>src/shared/models.py</code> <pre><code>class ZonedObjective(BaseModel):\n    \"\"\"\n    One hidden or visible objective, completed by taking pictures of its position.\n    \"\"\"\n\n    id: int  # could be null acording to Dto\n    name: str\n    start: datetime.datetime\n    end: datetime.datetime\n    decrease_rate: float\n    zone: Optional[tuple[int, int, int, int]]  # could be a str acording to dto\n    optic_required: CameraAngle  # cast from str\n    coverage_required: float\n    description: str  # cast from str\n    secret: bool\n    # sprite is ignored as said in email\n\n    @staticmethod\n    def parse_api(data: dict) -&gt; list[\"ZonedObjective\"]:  # type: ignore\n        \"\"\"\n        Extracts and parses objectives from its matching api endpoint\n        \"\"\"\n        z_obj_list = []\n        # parse objective list\n        for obj in data[\"zoned_objectives\"]:\n            if type(obj[\"zone\"]) is str:\n                zone = None\n            else:\n                zone = (\n                    int(obj[\"zone\"][0]),\n                    int(obj[\"zone\"][1]),\n                    int(obj[\"zone\"][2]),\n                    int(obj[\"zone\"][3]),\n                )\n\n            z_obj_list.append(\n                ZonedObjective(\n                    id=obj[\"id\"],\n                    name=obj[\"name\"],\n                    start=datetime.datetime.fromisoformat(obj[\"start\"]),\n                    end=datetime.datetime.fromisoformat(obj[\"end\"]),\n                    decrease_rate=obj[\"decrease_rate\"],\n                    zone=zone,\n                    optic_required=CameraAngle(obj[\"optic_required\"]),\n                    coverage_required=obj[\"coverage_required\"],\n                    description=obj[\"description\"],\n                    secret=obj[\"secret\"],\n                )\n            )\n\n        return sorted(z_obj_list, key=lambda event: event.start)\n</code></pre>"},{"location":"shared/#shared.models.ZonedObjective.coverage_required","title":"<code>coverage_required</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.ZonedObjective.decrease_rate","title":"<code>decrease_rate</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.ZonedObjective.description","title":"<code>description</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.ZonedObjective.end","title":"<code>end</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.ZonedObjective.id","title":"<code>id</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.ZonedObjective.name","title":"<code>name</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.ZonedObjective.optic_required","title":"<code>optic_required</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.ZonedObjective.secret","title":"<code>secret</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.ZonedObjective.start","title":"<code>start</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.ZonedObjective.zone","title":"<code>zone</code>  <code>instance-attribute</code>","text":""},{"location":"shared/#shared.models.ZonedObjective.parse_api","title":"<code>parse_api(data)</code>  <code>staticmethod</code>","text":"<p>Extracts and parses objectives from its matching api endpoint</p> Source code in <code>src/shared/models.py</code> <pre><code>@staticmethod\ndef parse_api(data: dict) -&gt; list[\"ZonedObjective\"]:  # type: ignore\n    \"\"\"\n    Extracts and parses objectives from its matching api endpoint\n    \"\"\"\n    z_obj_list = []\n    # parse objective list\n    for obj in data[\"zoned_objectives\"]:\n        if type(obj[\"zone\"]) is str:\n            zone = None\n        else:\n            zone = (\n                int(obj[\"zone\"][0]),\n                int(obj[\"zone\"][1]),\n                int(obj[\"zone\"][2]),\n                int(obj[\"zone\"][3]),\n            )\n\n        z_obj_list.append(\n            ZonedObjective(\n                id=obj[\"id\"],\n                name=obj[\"name\"],\n                start=datetime.datetime.fromisoformat(obj[\"start\"]),\n                end=datetime.datetime.fromisoformat(obj[\"end\"]),\n                decrease_rate=obj[\"decrease_rate\"],\n                zone=zone,\n                optic_required=CameraAngle(obj[\"optic_required\"]),\n                coverage_required=obj[\"coverage_required\"],\n                description=obj[\"description\"],\n                secret=obj[\"secret\"],\n            )\n        )\n\n    return sorted(z_obj_list, key=lambda event: event.start)\n</code></pre>"},{"location":"shared/#shared.models.lens_size_by_angle","title":"<code>lens_size_by_angle(angle)</code>","text":"<p>Returns covered area by a single picture.</p> Source code in <code>src/shared/models.py</code> <pre><code>def lens_size_by_angle(angle: CameraAngle) -&gt; int:\n    \"\"\"\n    Returns covered area by a single picture.\n    \"\"\"\n    match angle:\n        case CameraAngle.Narrow:\n            lens_size = 600\n        case CameraAngle.Normal:\n            lens_size = 800\n        case CameraAngle.Wide:\n            lens_size = 1000\n    return lens_size\n</code></pre>"},{"location":"shared/#shared.models.limited_log","title":"<code>limited_log(message)</code>","text":"<p>Log limit for info</p> Source code in <code>src/shared/models.py</code> <pre><code>@log_rate_limiter(3)  # type: ignore\ndef limited_log(message: str) -&gt; None:\n    \"\"\"Log limit for info\"\"\"\n    logger.info(message)\n</code></pre>"},{"location":"shared/#shared.models.limited_log_debug","title":"<code>limited_log_debug(message)</code>","text":"<p>Log limit for debug</p> Source code in <code>src/shared/models.py</code> <pre><code>@log_rate_limiter(1)  # type: ignore\ndef limited_log_debug(message: str) -&gt; None:\n    \"\"\"Log limit for debug\"\"\"\n    logger.debug(message)\n</code></pre>"},{"location":"shared/#shared.models.live_utc","title":"<code>live_utc()</code>","text":"<p>Returns live datetime object, including timezone utc</p> Source code in <code>src/shared/models.py</code> <pre><code>def live_utc() -&gt; datetime.datetime:\n    \"\"\"Returns live datetime object, including timezone utc\"\"\"\n    return datetime.datetime.now(datetime.timezone.utc)\n</code></pre>"},{"location":"shared/#shared.models.log_rate_limiter","title":"<code>log_rate_limiter(interval_seconds)</code>","text":"<p>Limits how often a single event can trigger a lot entry. Prevents cluttering of the same message. Probaly not a \"good\" final solution.</p> Source code in <code>src/shared/models.py</code> <pre><code>def log_rate_limiter(interval_seconds: int):  # type: ignore\n    \"\"\"\n    Limits how often a single event can trigger a lot entry. Prevents cluttering of the same message.\n    Probaly not a \"good\" final solution.\n    \"\"\"\n\n    # habe luhki nach loguru log rate limiter gefragt, gibt anscheinend keine besser inbuild l\u00f6sung\n    def decorator(func):  # type: ignore\n        last_log_time = [0]  # Use a list to allow modification of non-local state\n\n        def wrapper(*args, **kwargs):  # type: ignore\n            nonlocal last_log_time\n            current_time = time.time()\n            if current_time - last_log_time[0] &gt;= interval_seconds:\n                func(*args, **kwargs)\n                last_log_time[0] = current_time  # type: ignore\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"shared/#shared.models.time_seconds","title":"<code>time_seconds(date)</code>","text":"Source code in <code>src/shared/models.py</code> <pre><code>def time_seconds(date: datetime.datetime) -&gt; str:\n    return date.strftime(\"%Y-%m-%dT%H:%M:%S\")\n</code></pre>"},{"location":"coverage/","title":"Coverage Report","text":""}]}