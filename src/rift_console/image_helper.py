"""

Provides helping functions that are used in image_processing.

"""

import re
import os
import datetime

from shared.models import CameraAngle
import shared.constants as con

def generate_spiral_walk(n: int) -> list[tuple[int, int]]:
    """ Create an spiraling offset pattern arround a central point, e.g. (0,0), (0,1), (1,0), (1,1), ...
        sorted by Manhattan geometry

    Args:
        n (int): number of offsets to be generated

    Returns:
        list[tuple[int, int]]: list of offsets
    """
    
    # move right, up, left, down
    directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]
    # start with going right
    direction_index = 0
    
    x, y = 0, 0
    offsets = [(x, y)]
    
    # Number of steps we take before changing direction
    steps = 1
    
    while len(offsets) < n:
        for _ in range(2):
            for _ in range(steps):
                if len(offsets) < n:
                    # Move in the current direction
                    dx, dy = directions[direction_index]
                    x += dx
                    y += dy
                    # Add the new position to the spiral
                    offsets.append((x, y))
                else:
                    break
            # Change direction clockwise
            direction_index = (direction_index + 1) % 4
        # After moving two directions, we increase the number of steps
        steps += 1

    sorted_offset = sorted(offsets, key=lambda x: abs(x[0]) + abs(x[1]))
    return sorted_offset


def parse_image_name(name: str) -> tuple[int, int, int]:
    """ Parses an image name in the format generated by Melvonaut and extract the relevant properties for stitching

    Args:
        name (str): file name of the image

    Returns:
        tuple[int, int, int]: Used lenssize (and therefore if the image should be scaled to this later)
        and approximated x/y coordinates on the stiched image
    """
    # expected format: 'image_5344_wide_2024-12-11T17:31:27.507376_x_19936_y_4879'
    # with 8 underscores
    if len(name.split("_")) != con.IMAGE_NAME_UNDERSCORE_COUNT:
        raise Exception("parse_image_name: filename has wrong format!")

    # used CameraAngle is after second underscore
    match name.split("_")[con.IMAGE_ANGLE_POSITION]:
        case CameraAngle.Narrow:
            lens_size = 600
        case CameraAngle.Normal:
            lens_size = 800
        case CameraAngle.Wide:
            lens_size = 1000

    # find x and y in name
    match = re.search(r"_x_(-?\d+)_y_(-?\d+)", name)

    if match:
        x = int(match.group(1))
        y = int(match.group(2))
    else:
        raise Exception("parse_image_name: could not match x/y coordinates!")
    
    return lens_size, x, y


# returns all images
def find_image_names(directory: str) -> list[str]:
    """ Traverses the given directory and find + sorts all images in our filename format

    Args:
        directory (str): path to the folder, needs to include con.IMAGE_PATH

    Returns:
        list[str]: the name of all images in that folder, sorted by its timestamp from old to now
    """

    # find all names
    image_names = []
    for filename in os.listdir(directory):
        if filename.startswith("image"):
            image_names.append(filename)


    timestamp_pattern = r"_(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{6})"

    # helper function used in sorting
    def extract_timestamp(s):
        match = re.search(timestamp_pattern, s)
        if match:
            return datetime.datetime.fromisoformat(match.group(1))
        else:
            raise Exception(f"find_image_names: did not found timestamp in image names")

    # sort
    image_names = sorted(image_names, key=extract_timestamp)
    return image_names