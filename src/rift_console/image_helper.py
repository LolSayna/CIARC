"""

Provides helping functions that are used in image_processing.

"""

import re
import os
import datetime
from loguru import logger

import shared.constants as con
from shared.models import CameraAngle


def get_angle(image: str) -> CameraAngle:
    if "narrow" in image:
        return CameraAngle.Narrow
    elif "normal" in image:
        return CameraAngle.Normal
    elif "wide" in image:
        return CameraAngle.Wide
    logger.warning(f"Unknown camera angle in {image}")
    return CameraAngle.Unknown


def get_date(image: str) -> str:
    # pattern of year-month-dayThour-minute
    pattern = r"\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}"

    found_matches = re.findall(pattern, image)

    if len(found_matches) == 1:
        # logger.debug(found_matches[0])
        match: str = found_matches[0]
        return match
    else:
        logger.warning("None or two dates in {image}")
        return datetime.datetime.min.strftime("%Y-%m-%dT%H:%M:%S")


def filter_by_date(
    images: list[str], start: datetime.datetime, end: datetime.datetime
) -> list[str]:
    res = []
    date_format = "%Y-%m-%dT%H:%M:%S"
    for image in images:
        date = datetime.datetime.strptime(get_date(image), date_format).replace(
            tzinfo=datetime.timezone.utc
        )
        # logger.warning(f"{date} {start} {end}")
        if date >= start and date <= end:
            res.append(image)
    return res


def generate_spiral_walk(n: int) -> list[tuple[int, int]]:
    """Create an spiraling offset pattern arround a central point, e.g. (0,0), (0,1), (1,0), (1,1), ...
        sorted by Manhattan geometry

    Args:
        n (int): number of offsets to be generated

    Returns:
        list[tuple[int, int]]: list of offsets
    """

    # move right, up, left, down
    directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]
    # start with going right
    direction_index = 0

    x, y = 0, 0
    offsets = [(x, y)]

    # Number of steps we take before changing direction
    steps = 1

    while len(offsets) < n:
        for _ in range(2):
            for _ in range(steps):
                if len(offsets) < n:
                    # Move in the current direction
                    dx, dy = directions[direction_index]
                    x += dx
                    y += dy
                    # Add the new position to the spiral
                    offsets.append((x, y))
                else:
                    break
            # Change direction clockwise
            direction_index = (direction_index + 1) % 4
        # After moving two directions, we increase the number of steps
        steps += 1

    sorted_offset = sorted(offsets, key=lambda x: abs(x[0]) + abs(x[1]))
    return sorted_offset


def parse_image_name(name: str) -> tuple[int, int, int]:
    """Parses an image name in the format generated by Melvonaut and extract the relevant properties for stitching

    Args:
        name (str): file name of the image

    Returns:
        tuple[int, int, int]: Used lenssize (and therefore if the image should be scaled to this later)
        and approximated x/y coordinates on the stiched image
    """
    from shared.models import CameraAngle

    # expected format: 'image_5344_wide_2024-12-11T17:31:27.507376_x_19936_y_4879'
    # with 8 underscores
    if len(name.split("_")) != con.IMAGE_NAME_UNDERSCORE_COUNT:
        raise Exception("parse_image_name: filename has wrong format!")

    # used CameraAngle is after second underscore
    match name.split("_")[con.IMAGE_ANGLE_POSITION]:
        case CameraAngle.Narrow:
            lens_size = 600
        case CameraAngle.Normal:
            lens_size = 800
        case CameraAngle.Wide:
            lens_size = 1000

    # find x and y in name
    match = re.search(r"_x_(-?\d+)_y_(-?\d+)", name)

    if match:
        x = int(match.group(1))
        y = int(match.group(2))

        # old images position is not adjusted in melvonaut yet
        if con.USE_LEGACY_IMAGE_NAMES:
            x -= (int)(lens_size / 2)
            y -= (int)(lens_size / 2)
    else:
        raise Exception("parse_image_name: could not match x/y coordinates!")

    return lens_size, x, y


# returns all images
def find_image_names(directory: str) -> list[str]:
    """Traverses the given directory and find + sorts all images in our filename format

    Args:
        directory (str): path to the folder, needs to include con.IMAGE_PATH

    Returns:
        list[str]: the name of all images in that folder, sorted by its timestamp from old to now
    """

    # find all names
    image_names = []
    for filename in os.listdir(directory):
        if filename.startswith("image"):
            image_names.append(filename)

    # helper function used in sorting
    def extract_timestamp(s: str) -> datetime.datetime:
        timestamp_pattern = r"_(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{6})"

        match = re.search(timestamp_pattern, s)
        if match:
            return datetime.datetime.fromisoformat(match.group(1))
        else:
            raise Exception("find_image_names: did not found timestamp in image names")

    def extract_pos(s: str) -> int:
        pos_pattern = r"_x_(-?\d+)_y_(-?\d+)"

        match = re.search(pos_pattern, s)
        if match:
            x = int(match.group(1))
            y = int(match.group(2))
            return x + y
        else:
            raise Exception("find_image_names: did not found position in image names")

    # sort
    if con.SORT_IMAGE_BY_POSITION:
        image_names = sorted(image_names, key=extract_pos)
    else:
        image_names = sorted(image_names, key=extract_timestamp)
    return image_names
